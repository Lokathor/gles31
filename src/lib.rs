// file generated by `phosphorus-2.0.3`
// Args { xml: "../phosphorus/gl-2022-10-27.xml", api: "gles2", name:
// "GL_ES_VERSION_3_1", number: "3.1", ext: ["GL_KHR_debug"] }

//! Module for interfacing with `GL_ES_VERSION_3_1`.
//!
//! * Includes the `GL_KHR_debug` extension.
//!
//! Before actually calling any GL function, you must first
//! load the GL function pointers using [`load_gl_functions`].
//! Always do this *after* your GL context has been created.
//! Function pointers are loaded into global atomic variables,
//! so all GL contexts across all threads must use compatible
//! pointers. In practice, if all contexts are created using the
//! same context creation parameters they will have compatible
//! function pointers.
//!
//! On some platforms it's possible to load an extension function
//! without the extension being supported for your context.
//! Always check that your context supports an extension before
//! calling any extension function.
//!
//! Calling any GL function that isn't loaded will cause a panic.
#![allow(clippy::upper_case_acronyms)]
#![allow(dead_code)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(non_snake_case)]
#![allow(clippy::unused_unit)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::too_many_arguments)]
type GLenum = u32;
type GLbitfield = u32;
#[cfg(any(target_os = "ios", target_os = "macos"))]
type GLhandleARB = *mut void;
#[cfg(not(any(target_os = "ios", target_os = "macos")))]
type GLhandleARB = GLuint;
type GLeglClientBufferEXT = *mut void;
type GLeglImageOES = *mut void;
type GLsync = *mut void;
type _cl_context = void;
type _cl_event = void;
type GLDEBUGPROC = Option<
  unsafe extern "system" fn(
    source: GLenum,
    type_: GLenum,
    id: GLuint,
    severity: GLenum,
    length: GLsizei,
    message: *const GLchar,
    userParam: *const void,
  ),
>;
type GLDEBUGPROCARB = GLDEBUGPROC;
type GLDEBUGPROCKHR = GLDEBUGPROC;
type GLDEBUGPROCAMD = Option<
  unsafe extern "system" fn(
    id: GLuint,
    category: GLenum,
    severity: GLenum,
    length: GLsizei,
    message: *const GLchar,
    userParam: *mut void,
  ),
>;
type GLVULKANPROCNV = Option<unsafe extern "system" fn()>;
type GLboolean = u32;
type GLbyte = i8;
type GLcharARB = u8;
type GLclampd = f64;
type GLclampf = f32;
type GLclampx = i32;
type GLdouble = f64;
type GLfixed = i32;
type GLfloat = f32;
type GLhalf = u16;
type GLhalfARB = u16;
type GLhalfNV = u16;
type GLint = i32;
type GLint64 = i64;
type GLint64EXT = i64;
type GLintptr = isize;
type GLintptrARB = isize;
type GLshort = i16;
type GLsizei = u32;
type GLsizeiptr = isize;
type GLsizeiptrARB = isize;
type GLubyte = u8;
type GLuint = u32;
type GLuint64 = u64;
type GLuint64EXT = u64;
type GLushort = u16;
type GLvdpauSurfaceNV = GLintptr;
type void = core::ffi::c_void;
type GLchar = u8;

pub const GL_ACTIVE_ATOMIC_COUNTER_BUFFERS: u32 = 0x92D9;
pub const GL_ACTIVE_ATTRIBUTES: u32 = 0x8B89;
pub const GL_ACTIVE_ATTRIBUTE_MAX_LENGTH: u32 = 0x8B8A;
pub const GL_ACTIVE_PROGRAM: u32 = 0x8259;
pub const GL_ACTIVE_RESOURCES: u32 = 0x92F5;
pub const GL_ACTIVE_TEXTURE: u32 = 0x84E0;
pub const GL_ACTIVE_UNIFORMS: u32 = 0x8B86;
pub const GL_ACTIVE_UNIFORM_BLOCKS: u32 = 0x8A36;
pub const GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH: u32 = 0x8A35;
pub const GL_ACTIVE_UNIFORM_MAX_LENGTH: u32 = 0x8B87;
pub const GL_ACTIVE_VARIABLES: u32 = 0x9305;
pub const GL_ALIASED_LINE_WIDTH_RANGE: u32 = 0x846E;
pub const GL_ALIASED_POINT_SIZE_RANGE: u32 = 0x846D;
pub const GL_ALL_BARRIER_BITS: u32 = 0xFFFFFFFF;
pub const GL_ALL_SHADER_BITS: u32 = 0xFFFFFFFF;
pub const GL_ALPHA: u32 = 0x1906;
pub const GL_ALPHA_BITS: u32 = 0x0D55;
pub const GL_ALREADY_SIGNALED: u32 = 0x911A;
pub const GL_ALWAYS: u32 = 0x0207;
pub const GL_ANY_SAMPLES_PASSED: u32 = 0x8C2F;
pub const GL_ANY_SAMPLES_PASSED_CONSERVATIVE: u32 = 0x8D6A;
pub const GL_ARRAY_BUFFER: u32 = 0x8892;
pub const GL_ARRAY_BUFFER_BINDING: u32 = 0x8894;
pub const GL_ARRAY_SIZE: u32 = 0x92FB;
pub const GL_ARRAY_STRIDE: u32 = 0x92FE;
pub const GL_ATOMIC_COUNTER_BARRIER_BIT: u32 = 0x00001000;
pub const GL_ATOMIC_COUNTER_BUFFER: u32 = 0x92C0;
pub const GL_ATOMIC_COUNTER_BUFFER_BINDING: u32 = 0x92C1;
pub const GL_ATOMIC_COUNTER_BUFFER_INDEX: u32 = 0x9301;
pub const GL_ATOMIC_COUNTER_BUFFER_SIZE: u32 = 0x92C3;
pub const GL_ATOMIC_COUNTER_BUFFER_START: u32 = 0x92C2;
pub const GL_ATTACHED_SHADERS: u32 = 0x8B85;
pub const GL_BACK: u32 = 0x0405;
pub const GL_BLEND: u32 = 0x0BE2;
pub const GL_BLEND_COLOR: u32 = 0x8005;
pub const GL_BLEND_DST_ALPHA: u32 = 0x80CA;
pub const GL_BLEND_DST_RGB: u32 = 0x80C8;
pub const GL_BLEND_EQUATION: u32 = 0x8009;
pub const GL_BLEND_EQUATION_ALPHA: u32 = 0x883D;
pub const GL_BLEND_EQUATION_RGB: u32 = 0x8009;
pub const GL_BLEND_SRC_ALPHA: u32 = 0x80CB;
pub const GL_BLEND_SRC_RGB: u32 = 0x80C9;
pub const GL_BLOCK_INDEX: u32 = 0x92FD;
pub const GL_BLUE: u32 = 0x1905;
pub const GL_BLUE_BITS: u32 = 0x0D54;
pub const GL_BOOL: u32 = 0x8B56;
pub const GL_BOOL_VEC2: u32 = 0x8B57;
pub const GL_BOOL_VEC3: u32 = 0x8B58;
pub const GL_BOOL_VEC4: u32 = 0x8B59;
pub const GL_BUFFER_ACCESS_FLAGS: u32 = 0x911F;
pub const GL_BUFFER_BINDING: u32 = 0x9302;
pub const GL_BUFFER_DATA_SIZE: u32 = 0x9303;
pub const GL_BUFFER_KHR: u32 = 0x82E0;
pub const GL_BUFFER_MAPPED: u32 = 0x88BC;
pub const GL_BUFFER_MAP_LENGTH: u32 = 0x9120;
pub const GL_BUFFER_MAP_OFFSET: u32 = 0x9121;
pub const GL_BUFFER_MAP_POINTER: u32 = 0x88BD;
pub const GL_BUFFER_SIZE: u32 = 0x8764;
pub const GL_BUFFER_UPDATE_BARRIER_BIT: u32 = 0x00000200;
pub const GL_BUFFER_USAGE: u32 = 0x8765;
pub const GL_BUFFER_VARIABLE: u32 = 0x92E5;
pub const GL_BYTE: u32 = 0x1400;
pub const GL_CCW: u32 = 0x0901;
pub const GL_CLAMP_TO_EDGE: u32 = 0x812F;
pub const GL_COLOR: u32 = 0x1800;
pub const GL_COLOR_ATTACHMENT0: u32 = 0x8CE0;
pub const GL_COLOR_ATTACHMENT1: u32 = 0x8CE1;
pub const GL_COLOR_ATTACHMENT10: u32 = 0x8CEA;
pub const GL_COLOR_ATTACHMENT11: u32 = 0x8CEB;
pub const GL_COLOR_ATTACHMENT12: u32 = 0x8CEC;
pub const GL_COLOR_ATTACHMENT13: u32 = 0x8CED;
pub const GL_COLOR_ATTACHMENT14: u32 = 0x8CEE;
pub const GL_COLOR_ATTACHMENT15: u32 = 0x8CEF;
pub const GL_COLOR_ATTACHMENT16: u32 = 0x8CF0;
pub const GL_COLOR_ATTACHMENT17: u32 = 0x8CF1;
pub const GL_COLOR_ATTACHMENT18: u32 = 0x8CF2;
pub const GL_COLOR_ATTACHMENT19: u32 = 0x8CF3;
pub const GL_COLOR_ATTACHMENT2: u32 = 0x8CE2;
pub const GL_COLOR_ATTACHMENT20: u32 = 0x8CF4;
pub const GL_COLOR_ATTACHMENT21: u32 = 0x8CF5;
pub const GL_COLOR_ATTACHMENT22: u32 = 0x8CF6;
pub const GL_COLOR_ATTACHMENT23: u32 = 0x8CF7;
pub const GL_COLOR_ATTACHMENT24: u32 = 0x8CF8;
pub const GL_COLOR_ATTACHMENT25: u32 = 0x8CF9;
pub const GL_COLOR_ATTACHMENT26: u32 = 0x8CFA;
pub const GL_COLOR_ATTACHMENT27: u32 = 0x8CFB;
pub const GL_COLOR_ATTACHMENT28: u32 = 0x8CFC;
pub const GL_COLOR_ATTACHMENT29: u32 = 0x8CFD;
pub const GL_COLOR_ATTACHMENT3: u32 = 0x8CE3;
pub const GL_COLOR_ATTACHMENT30: u32 = 0x8CFE;
pub const GL_COLOR_ATTACHMENT31: u32 = 0x8CFF;
pub const GL_COLOR_ATTACHMENT4: u32 = 0x8CE4;
pub const GL_COLOR_ATTACHMENT5: u32 = 0x8CE5;
pub const GL_COLOR_ATTACHMENT6: u32 = 0x8CE6;
pub const GL_COLOR_ATTACHMENT7: u32 = 0x8CE7;
pub const GL_COLOR_ATTACHMENT8: u32 = 0x8CE8;
pub const GL_COLOR_ATTACHMENT9: u32 = 0x8CE9;
pub const GL_COLOR_BUFFER_BIT: u32 = 0x00004000;
pub const GL_COLOR_CLEAR_VALUE: u32 = 0x0C22;
pub const GL_COLOR_WRITEMASK: u32 = 0x0C23;
pub const GL_COMMAND_BARRIER_BIT: u32 = 0x00000040;
pub const GL_COMPARE_REF_TO_TEXTURE: u32 = 0x884E;
pub const GL_COMPILE_STATUS: u32 = 0x8B81;
pub const GL_COMPRESSED_R11_EAC: u32 = 0x9270;
pub const GL_COMPRESSED_RG11_EAC: u32 = 0x9272;
pub const GL_COMPRESSED_RGB8_ETC2: u32 = 0x9274;
pub const GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: u32 = 0x9276;
pub const GL_COMPRESSED_RGBA8_ETC2_EAC: u32 = 0x9278;
pub const GL_COMPRESSED_SIGNED_R11_EAC: u32 = 0x9271;
pub const GL_COMPRESSED_SIGNED_RG11_EAC: u32 = 0x9273;
pub const GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: u32 = 0x9279;
pub const GL_COMPRESSED_SRGB8_ETC2: u32 = 0x9275;
pub const GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: u32 = 0x9277;
pub const GL_COMPRESSED_TEXTURE_FORMATS: u32 = 0x86A3;
pub const GL_COMPUTE_SHADER: u32 = 0x91B9;
pub const GL_COMPUTE_SHADER_BIT: u32 = 0x00000020;
pub const GL_COMPUTE_WORK_GROUP_SIZE: u32 = 0x8267;
pub const GL_CONDITION_SATISFIED: u32 = 0x911C;
pub const GL_CONSTANT_ALPHA: u32 = 0x8003;
pub const GL_CONSTANT_COLOR: u32 = 0x8001;
pub const GL_CONTEXT_FLAG_DEBUG_BIT_KHR: u32 = 0x00000002;
pub const GL_COPY_READ_BUFFER: u32 = 0x8F36;
pub const GL_COPY_READ_BUFFER_BINDING: u32 = 0x8F36;
pub const GL_COPY_WRITE_BUFFER: u32 = 0x8F37;
pub const GL_COPY_WRITE_BUFFER_BINDING: u32 = 0x8F37;
pub const GL_CULL_FACE: u32 = 0x0B44;
pub const GL_CULL_FACE_MODE: u32 = 0x0B45;
pub const GL_CURRENT_PROGRAM: u32 = 0x8B8D;
pub const GL_CURRENT_QUERY: u32 = 0x8865;
pub const GL_CURRENT_VERTEX_ATTRIB: u32 = 0x8626;
pub const GL_CW: u32 = 0x0900;
pub const GL_DEBUG_CALLBACK_FUNCTION_KHR: u32 = 0x8244;
pub const GL_DEBUG_CALLBACK_USER_PARAM_KHR: u32 = 0x8245;
pub const GL_DEBUG_GROUP_STACK_DEPTH_KHR: u32 = 0x826D;
pub const GL_DEBUG_LOGGED_MESSAGES_KHR: u32 = 0x9145;
pub const GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_KHR: u32 = 0x8243;
pub const GL_DEBUG_OUTPUT_KHR: u32 = 0x92E0;
pub const GL_DEBUG_OUTPUT_SYNCHRONOUS_KHR: u32 = 0x8242;
pub const GL_DEBUG_SEVERITY_HIGH_KHR: u32 = 0x9146;
pub const GL_DEBUG_SEVERITY_LOW_KHR: u32 = 0x9148;
pub const GL_DEBUG_SEVERITY_MEDIUM_KHR: u32 = 0x9147;
pub const GL_DEBUG_SEVERITY_NOTIFICATION_KHR: u32 = 0x826B;
pub const GL_DEBUG_SOURCE_API_KHR: u32 = 0x8246;
pub const GL_DEBUG_SOURCE_APPLICATION_KHR: u32 = 0x824A;
pub const GL_DEBUG_SOURCE_OTHER_KHR: u32 = 0x824B;
pub const GL_DEBUG_SOURCE_SHADER_COMPILER_KHR: u32 = 0x8248;
pub const GL_DEBUG_SOURCE_THIRD_PARTY_KHR: u32 = 0x8249;
pub const GL_DEBUG_SOURCE_WINDOW_SYSTEM_KHR: u32 = 0x8247;
pub const GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_KHR: u32 = 0x824D;
pub const GL_DEBUG_TYPE_ERROR_KHR: u32 = 0x824C;
pub const GL_DEBUG_TYPE_MARKER_KHR: u32 = 0x8268;
pub const GL_DEBUG_TYPE_OTHER_KHR: u32 = 0x8251;
pub const GL_DEBUG_TYPE_PERFORMANCE_KHR: u32 = 0x8250;
pub const GL_DEBUG_TYPE_POP_GROUP_KHR: u32 = 0x826A;
pub const GL_DEBUG_TYPE_PORTABILITY_KHR: u32 = 0x824F;
pub const GL_DEBUG_TYPE_PUSH_GROUP_KHR: u32 = 0x8269;
pub const GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_KHR: u32 = 0x824E;
pub const GL_DECR: u32 = 0x1E03;
pub const GL_DECR_WRAP: u32 = 0x8508;
pub const GL_DELETE_STATUS: u32 = 0x8B80;
pub const GL_DEPTH: u32 = 0x1801;
pub const GL_DEPTH24_STENCIL8: u32 = 0x88F0;
pub const GL_DEPTH32F_STENCIL8: u32 = 0x8CAD;
pub const GL_DEPTH_ATTACHMENT: u32 = 0x8D00;
pub const GL_DEPTH_BITS: u32 = 0x0D56;
pub const GL_DEPTH_BUFFER_BIT: u32 = 0x00000100;
pub const GL_DEPTH_CLEAR_VALUE: u32 = 0x0B73;
pub const GL_DEPTH_COMPONENT: u32 = 0x1902;
pub const GL_DEPTH_COMPONENT16: u32 = 0x81A5;
pub const GL_DEPTH_COMPONENT24: u32 = 0x81A6;
pub const GL_DEPTH_COMPONENT32F: u32 = 0x8CAC;
pub const GL_DEPTH_FUNC: u32 = 0x0B74;
pub const GL_DEPTH_RANGE: u32 = 0x0B70;
pub const GL_DEPTH_STENCIL: u32 = 0x84F9;
pub const GL_DEPTH_STENCIL_ATTACHMENT: u32 = 0x821A;
pub const GL_DEPTH_STENCIL_TEXTURE_MODE: u32 = 0x90EA;
pub const GL_DEPTH_TEST: u32 = 0x0B71;
pub const GL_DEPTH_WRITEMASK: u32 = 0x0B72;
pub const GL_DISPATCH_INDIRECT_BUFFER: u32 = 0x90EE;
pub const GL_DISPATCH_INDIRECT_BUFFER_BINDING: u32 = 0x90EF;
pub const GL_DITHER: u32 = 0x0BD0;
pub const GL_DONT_CARE: u32 = 0x1100;
pub const GL_DRAW_BUFFER0: u32 = 0x8825;
pub const GL_DRAW_BUFFER1: u32 = 0x8826;
pub const GL_DRAW_BUFFER10: u32 = 0x882F;
pub const GL_DRAW_BUFFER11: u32 = 0x8830;
pub const GL_DRAW_BUFFER12: u32 = 0x8831;
pub const GL_DRAW_BUFFER13: u32 = 0x8832;
pub const GL_DRAW_BUFFER14: u32 = 0x8833;
pub const GL_DRAW_BUFFER15: u32 = 0x8834;
pub const GL_DRAW_BUFFER2: u32 = 0x8827;
pub const GL_DRAW_BUFFER3: u32 = 0x8828;
pub const GL_DRAW_BUFFER4: u32 = 0x8829;
pub const GL_DRAW_BUFFER5: u32 = 0x882A;
pub const GL_DRAW_BUFFER6: u32 = 0x882B;
pub const GL_DRAW_BUFFER7: u32 = 0x882C;
pub const GL_DRAW_BUFFER8: u32 = 0x882D;
pub const GL_DRAW_BUFFER9: u32 = 0x882E;
pub const GL_DRAW_FRAMEBUFFER: u32 = 0x8CA9;
pub const GL_DRAW_FRAMEBUFFER_BINDING: u32 = 0x8CA6;
pub const GL_DRAW_INDIRECT_BUFFER: u32 = 0x8F3F;
pub const GL_DRAW_INDIRECT_BUFFER_BINDING: u32 = 0x8F43;
pub const GL_DST_ALPHA: u32 = 0x0304;
pub const GL_DST_COLOR: u32 = 0x0306;
pub const GL_DYNAMIC_COPY: u32 = 0x88EA;
pub const GL_DYNAMIC_DRAW: u32 = 0x88E8;
pub const GL_DYNAMIC_READ: u32 = 0x88E9;
pub const GL_ELEMENT_ARRAY_BARRIER_BIT: u32 = 0x00000002;
pub const GL_ELEMENT_ARRAY_BUFFER: u32 = 0x8893;
pub const GL_ELEMENT_ARRAY_BUFFER_BINDING: u32 = 0x8895;
pub const GL_EQUAL: u32 = 0x0202;
pub const GL_EXTENSIONS: u32 = 0x1F03;
pub const GL_FALSE: u32 = 0;
pub const GL_FASTEST: u32 = 0x1101;
pub const GL_FIXED: u32 = 0x140C;
pub const GL_FLOAT: u32 = 0x1406;
pub const GL_FLOAT_32_UNSIGNED_INT_24_8_REV: u32 = 0x8DAD;
pub const GL_FLOAT_MAT2: u32 = 0x8B5A;
#[allow(non_upper_case_globals)]
pub const GL_FLOAT_MAT2x3: u32 = 0x8B65;
#[allow(non_upper_case_globals)]
pub const GL_FLOAT_MAT2x4: u32 = 0x8B66;
pub const GL_FLOAT_MAT3: u32 = 0x8B5B;
#[allow(non_upper_case_globals)]
pub const GL_FLOAT_MAT3x2: u32 = 0x8B67;
#[allow(non_upper_case_globals)]
pub const GL_FLOAT_MAT3x4: u32 = 0x8B68;
pub const GL_FLOAT_MAT4: u32 = 0x8B5C;
#[allow(non_upper_case_globals)]
pub const GL_FLOAT_MAT4x2: u32 = 0x8B69;
#[allow(non_upper_case_globals)]
pub const GL_FLOAT_MAT4x3: u32 = 0x8B6A;
pub const GL_FLOAT_VEC2: u32 = 0x8B50;
pub const GL_FLOAT_VEC3: u32 = 0x8B51;
pub const GL_FLOAT_VEC4: u32 = 0x8B52;
pub const GL_FRAGMENT_SHADER: u32 = 0x8B30;
pub const GL_FRAGMENT_SHADER_BIT: u32 = 0x00000002;
pub const GL_FRAGMENT_SHADER_DERIVATIVE_HINT: u32 = 0x8B8B;
pub const GL_FRAMEBUFFER: u32 = 0x8D40;
pub const GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: u32 = 0x8215;
pub const GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: u32 = 0x8214;
pub const GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: u32 = 0x8210;
pub const GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: u32 = 0x8211;
pub const GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: u32 = 0x8216;
pub const GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: u32 = 0x8213;
pub const GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: u32 = 0x8CD1;
pub const GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: u32 = 0x8CD0;
pub const GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE: u32 = 0x8212;
pub const GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: u32 = 0x8217;
pub const GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: u32 = 0x8CD3;
pub const GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: u32 = 0x8CD4;
pub const GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: u32 = 0x8CD2;
pub const GL_FRAMEBUFFER_BARRIER_BIT: u32 = 0x00000400;
pub const GL_FRAMEBUFFER_BINDING: u32 = 0x8CA6;
pub const GL_FRAMEBUFFER_COMPLETE: u32 = 0x8CD5;
pub const GL_FRAMEBUFFER_DEFAULT: u32 = 0x8218;
pub const GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS: u32 = 0x9314;
pub const GL_FRAMEBUFFER_DEFAULT_HEIGHT: u32 = 0x9311;
pub const GL_FRAMEBUFFER_DEFAULT_SAMPLES: u32 = 0x9313;
pub const GL_FRAMEBUFFER_DEFAULT_WIDTH: u32 = 0x9310;
pub const GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT: u32 = 0x8CD6;
pub const GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS: u32 = 0x8CD9;
pub const GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: u32 = 0x8CD7;
pub const GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: u32 = 0x8D56;
pub const GL_FRAMEBUFFER_UNDEFINED: u32 = 0x8219;
pub const GL_FRAMEBUFFER_UNSUPPORTED: u32 = 0x8CDD;
pub const GL_FRONT: u32 = 0x0404;
pub const GL_FRONT_AND_BACK: u32 = 0x0408;
pub const GL_FRONT_FACE: u32 = 0x0B46;
pub const GL_FUNC_ADD: u32 = 0x8006;
pub const GL_FUNC_REVERSE_SUBTRACT: u32 = 0x800B;
pub const GL_FUNC_SUBTRACT: u32 = 0x800A;
pub const GL_GENERATE_MIPMAP_HINT: u32 = 0x8192;
pub const GL_GEQUAL: u32 = 0x0206;
pub const GL_GREATER: u32 = 0x0204;
pub const GL_GREEN: u32 = 0x1904;
pub const GL_GREEN_BITS: u32 = 0x0D53;
pub const GL_HALF_FLOAT: u32 = 0x140B;
pub const GL_HIGH_FLOAT: u32 = 0x8DF2;
pub const GL_HIGH_INT: u32 = 0x8DF5;
pub const GL_IMAGE_2D: u32 = 0x904D;
pub const GL_IMAGE_2D_ARRAY: u32 = 0x9053;
pub const GL_IMAGE_3D: u32 = 0x904E;
pub const GL_IMAGE_BINDING_ACCESS: u32 = 0x8F3E;
pub const GL_IMAGE_BINDING_FORMAT: u32 = 0x906E;
pub const GL_IMAGE_BINDING_LAYER: u32 = 0x8F3D;
pub const GL_IMAGE_BINDING_LAYERED: u32 = 0x8F3C;
pub const GL_IMAGE_BINDING_LEVEL: u32 = 0x8F3B;
pub const GL_IMAGE_BINDING_NAME: u32 = 0x8F3A;
pub const GL_IMAGE_CUBE: u32 = 0x9050;
pub const GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS: u32 = 0x90C9;
pub const GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE: u32 = 0x90C8;
pub const GL_IMAGE_FORMAT_COMPATIBILITY_TYPE: u32 = 0x90C7;
pub const GL_IMPLEMENTATION_COLOR_READ_FORMAT: u32 = 0x8B9B;
pub const GL_IMPLEMENTATION_COLOR_READ_TYPE: u32 = 0x8B9A;
pub const GL_INCR: u32 = 0x1E02;
pub const GL_INCR_WRAP: u32 = 0x8507;
pub const GL_INFO_LOG_LENGTH: u32 = 0x8B84;
pub const GL_INT: u32 = 0x1404;
pub const GL_INTERLEAVED_ATTRIBS: u32 = 0x8C8C;
pub const GL_INT_2_10_10_10_REV: u32 = 0x8D9F;
pub const GL_INT_IMAGE_2D: u32 = 0x9058;
pub const GL_INT_IMAGE_2D_ARRAY: u32 = 0x905E;
pub const GL_INT_IMAGE_3D: u32 = 0x9059;
pub const GL_INT_IMAGE_CUBE: u32 = 0x905B;
pub const GL_INT_SAMPLER_2D: u32 = 0x8DCA;
pub const GL_INT_SAMPLER_2D_ARRAY: u32 = 0x8DCF;
pub const GL_INT_SAMPLER_2D_MULTISAMPLE: u32 = 0x9109;
pub const GL_INT_SAMPLER_3D: u32 = 0x8DCB;
pub const GL_INT_SAMPLER_CUBE: u32 = 0x8DCC;
pub const GL_INT_VEC2: u32 = 0x8B53;
pub const GL_INT_VEC3: u32 = 0x8B54;
pub const GL_INT_VEC4: u32 = 0x8B55;
pub const GL_INVALID_ENUM: u32 = 0x0500;
pub const GL_INVALID_FRAMEBUFFER_OPERATION: u32 = 0x0506;
pub const GL_INVALID_INDEX: u32 = 0xFFFFFFFF;
pub const GL_INVALID_OPERATION: u32 = 0x0502;
pub const GL_INVALID_VALUE: u32 = 0x0501;
pub const GL_INVERT: u32 = 0x150A;
pub const GL_IS_ROW_MAJOR: u32 = 0x9300;
pub const GL_KEEP: u32 = 0x1E00;
pub const GL_LEQUAL: u32 = 0x0203;
pub const GL_LESS: u32 = 0x0201;
pub const GL_LINEAR: u32 = 0x2601;
pub const GL_LINEAR_MIPMAP_LINEAR: u32 = 0x2703;
pub const GL_LINEAR_MIPMAP_NEAREST: u32 = 0x2701;
pub const GL_LINES: u32 = 0x0001;
pub const GL_LINE_LOOP: u32 = 0x0002;
pub const GL_LINE_STRIP: u32 = 0x0003;
pub const GL_LINE_WIDTH: u32 = 0x0B21;
pub const GL_LINK_STATUS: u32 = 0x8B82;
pub const GL_LOCATION: u32 = 0x930E;
pub const GL_LOW_FLOAT: u32 = 0x8DF0;
pub const GL_LOW_INT: u32 = 0x8DF3;
pub const GL_LUMINANCE: u32 = 0x1909;
pub const GL_LUMINANCE_ALPHA: u32 = 0x190A;
pub const GL_MAJOR_VERSION: u32 = 0x821B;
pub const GL_MAP_FLUSH_EXPLICIT_BIT: u32 = 0x0010;
pub const GL_MAP_INVALIDATE_BUFFER_BIT: u32 = 0x0008;
pub const GL_MAP_INVALIDATE_RANGE_BIT: u32 = 0x0004;
pub const GL_MAP_READ_BIT: u32 = 0x0001;
pub const GL_MAP_UNSYNCHRONIZED_BIT: u32 = 0x0020;
pub const GL_MAP_WRITE_BIT: u32 = 0x0002;
pub const GL_MATRIX_STRIDE: u32 = 0x92FF;
pub const GL_MAX: u32 = 0x8008;
pub const GL_MAX_3D_TEXTURE_SIZE: u32 = 0x8073;
pub const GL_MAX_ARRAY_TEXTURE_LAYERS: u32 = 0x88FF;
pub const GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS: u32 = 0x92DC;
pub const GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE: u32 = 0x92D8;
pub const GL_MAX_COLOR_ATTACHMENTS: u32 = 0x8CDF;
pub const GL_MAX_COLOR_TEXTURE_SAMPLES: u32 = 0x910E;
pub const GL_MAX_COMBINED_ATOMIC_COUNTERS: u32 = 0x92D7;
pub const GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS: u32 = 0x92D1;
pub const GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS: u32 = 0x8266;
pub const GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: u32 = 0x8A33;
pub const GL_MAX_COMBINED_IMAGE_UNIFORMS: u32 = 0x90CF;
pub const GL_MAX_COMBINED_SHADER_OUTPUT_RESOURCES: u32 = 0x8F39;
pub const GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS: u32 = 0x90DC;
pub const GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS: u32 = 0x8B4D;
pub const GL_MAX_COMBINED_UNIFORM_BLOCKS: u32 = 0x8A2E;
pub const GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: u32 = 0x8A31;
pub const GL_MAX_COMPUTE_ATOMIC_COUNTERS: u32 = 0x8265;
pub const GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS: u32 = 0x8264;
pub const GL_MAX_COMPUTE_IMAGE_UNIFORMS: u32 = 0x91BD;
pub const GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS: u32 = 0x90DB;
pub const GL_MAX_COMPUTE_SHARED_MEMORY_SIZE: u32 = 0x8262;
pub const GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS: u32 = 0x91BC;
pub const GL_MAX_COMPUTE_UNIFORM_BLOCKS: u32 = 0x91BB;
pub const GL_MAX_COMPUTE_UNIFORM_COMPONENTS: u32 = 0x8263;
pub const GL_MAX_COMPUTE_WORK_GROUP_COUNT: u32 = 0x91BE;
pub const GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS: u32 = 0x90EB;
pub const GL_MAX_COMPUTE_WORK_GROUP_SIZE: u32 = 0x91BF;
pub const GL_MAX_CUBE_MAP_TEXTURE_SIZE: u32 = 0x851C;
pub const GL_MAX_DEBUG_GROUP_STACK_DEPTH_KHR: u32 = 0x826C;
pub const GL_MAX_DEBUG_LOGGED_MESSAGES_KHR: u32 = 0x9144;
pub const GL_MAX_DEBUG_MESSAGE_LENGTH_KHR: u32 = 0x9143;
pub const GL_MAX_DEPTH_TEXTURE_SAMPLES: u32 = 0x910F;
pub const GL_MAX_DRAW_BUFFERS: u32 = 0x8824;
pub const GL_MAX_ELEMENTS_INDICES: u32 = 0x80E9;
pub const GL_MAX_ELEMENTS_VERTICES: u32 = 0x80E8;
pub const GL_MAX_ELEMENT_INDEX: u32 = 0x8D6B;
pub const GL_MAX_FRAGMENT_ATOMIC_COUNTERS: u32 = 0x92D6;
pub const GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS: u32 = 0x92D0;
pub const GL_MAX_FRAGMENT_IMAGE_UNIFORMS: u32 = 0x90CE;
pub const GL_MAX_FRAGMENT_INPUT_COMPONENTS: u32 = 0x9125;
pub const GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS: u32 = 0x90DA;
pub const GL_MAX_FRAGMENT_UNIFORM_BLOCKS: u32 = 0x8A2D;
pub const GL_MAX_FRAGMENT_UNIFORM_COMPONENTS: u32 = 0x8B49;
pub const GL_MAX_FRAGMENT_UNIFORM_VECTORS: u32 = 0x8DFD;
pub const GL_MAX_FRAMEBUFFER_HEIGHT: u32 = 0x9316;
pub const GL_MAX_FRAMEBUFFER_SAMPLES: u32 = 0x9318;
pub const GL_MAX_FRAMEBUFFER_WIDTH: u32 = 0x9315;
pub const GL_MAX_IMAGE_UNITS: u32 = 0x8F38;
pub const GL_MAX_INTEGER_SAMPLES: u32 = 0x9110;
pub const GL_MAX_LABEL_LENGTH_KHR: u32 = 0x82E8;
pub const GL_MAX_NAME_LENGTH: u32 = 0x92F6;
pub const GL_MAX_NUM_ACTIVE_VARIABLES: u32 = 0x92F7;
pub const GL_MAX_PROGRAM_TEXEL_OFFSET: u32 = 0x8905;
pub const GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET: u32 = 0x8E5F;
pub const GL_MAX_RENDERBUFFER_SIZE: u32 = 0x84E8;
pub const GL_MAX_SAMPLES: u32 = 0x8D57;
pub const GL_MAX_SAMPLE_MASK_WORDS: u32 = 0x8E59;
pub const GL_MAX_SERVER_WAIT_TIMEOUT: u32 = 0x9111;
pub const GL_MAX_SHADER_STORAGE_BLOCK_SIZE: u32 = 0x90DE;
pub const GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS: u32 = 0x90DD;
pub const GL_MAX_TEXTURE_IMAGE_UNITS: u32 = 0x8872;
pub const GL_MAX_TEXTURE_LOD_BIAS: u32 = 0x84FD;
pub const GL_MAX_TEXTURE_SIZE: u32 = 0x0D33;
pub const GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: u32 = 0x8C8A;
pub const GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: u32 = 0x8C8B;
pub const GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: u32 = 0x8C80;
pub const GL_MAX_UNIFORM_BLOCK_SIZE: u32 = 0x8A30;
pub const GL_MAX_UNIFORM_BUFFER_BINDINGS: u32 = 0x8A2F;
pub const GL_MAX_UNIFORM_LOCATIONS: u32 = 0x826E;
pub const GL_MAX_VARYING_COMPONENTS: u32 = 0x8B4B;
pub const GL_MAX_VARYING_VECTORS: u32 = 0x8DFC;
pub const GL_MAX_VERTEX_ATOMIC_COUNTERS: u32 = 0x92D2;
pub const GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS: u32 = 0x92CC;
pub const GL_MAX_VERTEX_ATTRIBS: u32 = 0x8869;
pub const GL_MAX_VERTEX_ATTRIB_BINDINGS: u32 = 0x82DA;
pub const GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET: u32 = 0x82D9;
pub const GL_MAX_VERTEX_ATTRIB_STRIDE: u32 = 0x82E5;
pub const GL_MAX_VERTEX_IMAGE_UNIFORMS: u32 = 0x90CA;
pub const GL_MAX_VERTEX_OUTPUT_COMPONENTS: u32 = 0x9122;
pub const GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS: u32 = 0x90D6;
pub const GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS: u32 = 0x8B4C;
pub const GL_MAX_VERTEX_UNIFORM_BLOCKS: u32 = 0x8A2B;
pub const GL_MAX_VERTEX_UNIFORM_COMPONENTS: u32 = 0x8B4A;
pub const GL_MAX_VERTEX_UNIFORM_VECTORS: u32 = 0x8DFB;
pub const GL_MAX_VIEWPORT_DIMS: u32 = 0x0D3A;
pub const GL_MEDIUM_FLOAT: u32 = 0x8DF1;
pub const GL_MEDIUM_INT: u32 = 0x8DF4;
pub const GL_MIN: u32 = 0x8007;
pub const GL_MINOR_VERSION: u32 = 0x821C;
pub const GL_MIN_PROGRAM_TEXEL_OFFSET: u32 = 0x8904;
pub const GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET: u32 = 0x8E5E;
pub const GL_MIRRORED_REPEAT: u32 = 0x8370;
pub const GL_NAME_LENGTH: u32 = 0x92F9;
pub const GL_NEAREST: u32 = 0x2600;
pub const GL_NEAREST_MIPMAP_LINEAR: u32 = 0x2702;
pub const GL_NEAREST_MIPMAP_NEAREST: u32 = 0x2700;
pub const GL_NEVER: u32 = 0x0200;
pub const GL_NICEST: u32 = 0x1102;
pub const GL_NONE: u32 = 0;
pub const GL_NOTEQUAL: u32 = 0x0205;
pub const GL_NO_ERROR: u32 = 0;
pub const GL_NUM_ACTIVE_VARIABLES: u32 = 0x9304;
pub const GL_NUM_COMPRESSED_TEXTURE_FORMATS: u32 = 0x86A2;
pub const GL_NUM_EXTENSIONS: u32 = 0x821D;
pub const GL_NUM_PROGRAM_BINARY_FORMATS: u32 = 0x87FE;
pub const GL_NUM_SAMPLE_COUNTS: u32 = 0x9380;
pub const GL_NUM_SHADER_BINARY_FORMATS: u32 = 0x8DF9;
pub const GL_OBJECT_TYPE: u32 = 0x9112;
pub const GL_OFFSET: u32 = 0x92FC;
pub const GL_ONE: u32 = 1;
pub const GL_ONE_MINUS_CONSTANT_ALPHA: u32 = 0x8004;
pub const GL_ONE_MINUS_CONSTANT_COLOR: u32 = 0x8002;
pub const GL_ONE_MINUS_DST_ALPHA: u32 = 0x0305;
pub const GL_ONE_MINUS_DST_COLOR: u32 = 0x0307;
pub const GL_ONE_MINUS_SRC_ALPHA: u32 = 0x0303;
pub const GL_ONE_MINUS_SRC_COLOR: u32 = 0x0301;
pub const GL_OUT_OF_MEMORY: u32 = 0x0505;
pub const GL_PACK_ALIGNMENT: u32 = 0x0D05;
pub const GL_PACK_ROW_LENGTH: u32 = 0x0D02;
pub const GL_PACK_SKIP_PIXELS: u32 = 0x0D04;
pub const GL_PACK_SKIP_ROWS: u32 = 0x0D03;
pub const GL_PIXEL_BUFFER_BARRIER_BIT: u32 = 0x00000080;
pub const GL_PIXEL_PACK_BUFFER: u32 = 0x88EB;
pub const GL_PIXEL_PACK_BUFFER_BINDING: u32 = 0x88ED;
pub const GL_PIXEL_UNPACK_BUFFER: u32 = 0x88EC;
pub const GL_PIXEL_UNPACK_BUFFER_BINDING: u32 = 0x88EF;
pub const GL_POINTS: u32 = 0x0000;
pub const GL_POLYGON_OFFSET_FACTOR: u32 = 0x8038;
pub const GL_POLYGON_OFFSET_FILL: u32 = 0x8037;
pub const GL_POLYGON_OFFSET_UNITS: u32 = 0x2A00;
pub const GL_PRIMITIVE_RESTART_FIXED_INDEX: u32 = 0x8D69;
pub const GL_PROGRAM_BINARY_FORMATS: u32 = 0x87FF;
pub const GL_PROGRAM_BINARY_LENGTH: u32 = 0x8741;
pub const GL_PROGRAM_BINARY_RETRIEVABLE_HINT: u32 = 0x8257;
pub const GL_PROGRAM_INPUT: u32 = 0x92E3;
pub const GL_PROGRAM_KHR: u32 = 0x82E2;
pub const GL_PROGRAM_OUTPUT: u32 = 0x92E4;
pub const GL_PROGRAM_PIPELINE_BINDING: u32 = 0x825A;
pub const GL_PROGRAM_PIPELINE_KHR: u32 = 0x82E4;
pub const GL_PROGRAM_SEPARABLE: u32 = 0x8258;
pub const GL_QUERY_KHR: u32 = 0x82E3;
pub const GL_QUERY_RESULT: u32 = 0x8866;
pub const GL_QUERY_RESULT_AVAILABLE: u32 = 0x8867;
pub const GL_R11F_G11F_B10F: u32 = 0x8C3A;
pub const GL_R16F: u32 = 0x822D;
pub const GL_R16I: u32 = 0x8233;
pub const GL_R16UI: u32 = 0x8234;
pub const GL_R32F: u32 = 0x822E;
pub const GL_R32I: u32 = 0x8235;
pub const GL_R32UI: u32 = 0x8236;
pub const GL_R8: u32 = 0x8229;
pub const GL_R8I: u32 = 0x8231;
pub const GL_R8UI: u32 = 0x8232;
pub const GL_R8_SNORM: u32 = 0x8F94;
pub const GL_RASTERIZER_DISCARD: u32 = 0x8C89;
pub const GL_READ_BUFFER: u32 = 0x0C02;
pub const GL_READ_FRAMEBUFFER: u32 = 0x8CA8;
pub const GL_READ_FRAMEBUFFER_BINDING: u32 = 0x8CAA;
pub const GL_READ_ONLY: u32 = 0x88B8;
pub const GL_READ_WRITE: u32 = 0x88BA;
pub const GL_RED: u32 = 0x1903;
pub const GL_RED_BITS: u32 = 0x0D52;
pub const GL_RED_INTEGER: u32 = 0x8D94;
pub const GL_REFERENCED_BY_COMPUTE_SHADER: u32 = 0x930B;
pub const GL_REFERENCED_BY_FRAGMENT_SHADER: u32 = 0x930A;
pub const GL_REFERENCED_BY_VERTEX_SHADER: u32 = 0x9306;
pub const GL_RENDERBUFFER: u32 = 0x8D41;
pub const GL_RENDERBUFFER_ALPHA_SIZE: u32 = 0x8D53;
pub const GL_RENDERBUFFER_BINDING: u32 = 0x8CA7;
pub const GL_RENDERBUFFER_BLUE_SIZE: u32 = 0x8D52;
pub const GL_RENDERBUFFER_DEPTH_SIZE: u32 = 0x8D54;
pub const GL_RENDERBUFFER_GREEN_SIZE: u32 = 0x8D51;
pub const GL_RENDERBUFFER_HEIGHT: u32 = 0x8D43;
pub const GL_RENDERBUFFER_INTERNAL_FORMAT: u32 = 0x8D44;
pub const GL_RENDERBUFFER_RED_SIZE: u32 = 0x8D50;
pub const GL_RENDERBUFFER_SAMPLES: u32 = 0x8CAB;
pub const GL_RENDERBUFFER_STENCIL_SIZE: u32 = 0x8D55;
pub const GL_RENDERBUFFER_WIDTH: u32 = 0x8D42;
pub const GL_RENDERER: u32 = 0x1F01;
pub const GL_REPEAT: u32 = 0x2901;
pub const GL_REPLACE: u32 = 0x1E01;
pub const GL_RG: u32 = 0x8227;
pub const GL_RG16F: u32 = 0x822F;
pub const GL_RG16I: u32 = 0x8239;
pub const GL_RG16UI: u32 = 0x823A;
pub const GL_RG32F: u32 = 0x8230;
pub const GL_RG32I: u32 = 0x823B;
pub const GL_RG32UI: u32 = 0x823C;
pub const GL_RG8: u32 = 0x822B;
pub const GL_RG8I: u32 = 0x8237;
pub const GL_RG8UI: u32 = 0x8238;
pub const GL_RG8_SNORM: u32 = 0x8F95;
pub const GL_RGB: u32 = 0x1907;
pub const GL_RGB10_A2: u32 = 0x8059;
pub const GL_RGB10_A2UI: u32 = 0x906F;
pub const GL_RGB16F: u32 = 0x881B;
pub const GL_RGB16I: u32 = 0x8D89;
pub const GL_RGB16UI: u32 = 0x8D77;
pub const GL_RGB32F: u32 = 0x8815;
pub const GL_RGB32I: u32 = 0x8D83;
pub const GL_RGB32UI: u32 = 0x8D71;
pub const GL_RGB565: u32 = 0x8D62;
pub const GL_RGB5_A1: u32 = 0x8057;
pub const GL_RGB8: u32 = 0x8051;
pub const GL_RGB8I: u32 = 0x8D8F;
pub const GL_RGB8UI: u32 = 0x8D7D;
pub const GL_RGB8_SNORM: u32 = 0x8F96;
pub const GL_RGB9_E5: u32 = 0x8C3D;
pub const GL_RGBA: u32 = 0x1908;
pub const GL_RGBA16F: u32 = 0x881A;
pub const GL_RGBA16I: u32 = 0x8D88;
pub const GL_RGBA16UI: u32 = 0x8D76;
pub const GL_RGBA32F: u32 = 0x8814;
pub const GL_RGBA32I: u32 = 0x8D82;
pub const GL_RGBA32UI: u32 = 0x8D70;
pub const GL_RGBA4: u32 = 0x8056;
pub const GL_RGBA8: u32 = 0x8058;
pub const GL_RGBA8I: u32 = 0x8D8E;
pub const GL_RGBA8UI: u32 = 0x8D7C;
pub const GL_RGBA8_SNORM: u32 = 0x8F97;
pub const GL_RGBA_INTEGER: u32 = 0x8D99;
pub const GL_RGB_INTEGER: u32 = 0x8D98;
pub const GL_RG_INTEGER: u32 = 0x8228;
pub const GL_SAMPLER_2D: u32 = 0x8B5E;
pub const GL_SAMPLER_2D_ARRAY: u32 = 0x8DC1;
pub const GL_SAMPLER_2D_ARRAY_SHADOW: u32 = 0x8DC4;
pub const GL_SAMPLER_2D_MULTISAMPLE: u32 = 0x9108;
pub const GL_SAMPLER_2D_SHADOW: u32 = 0x8B62;
pub const GL_SAMPLER_3D: u32 = 0x8B5F;
pub const GL_SAMPLER_BINDING: u32 = 0x8919;
pub const GL_SAMPLER_CUBE: u32 = 0x8B60;
pub const GL_SAMPLER_CUBE_SHADOW: u32 = 0x8DC5;
pub const GL_SAMPLER_KHR: u32 = 0x82E6;
pub const GL_SAMPLES: u32 = 0x80A9;
pub const GL_SAMPLE_ALPHA_TO_COVERAGE: u32 = 0x809E;
pub const GL_SAMPLE_BUFFERS: u32 = 0x80A8;
pub const GL_SAMPLE_COVERAGE: u32 = 0x80A0;
pub const GL_SAMPLE_COVERAGE_INVERT: u32 = 0x80AB;
pub const GL_SAMPLE_COVERAGE_VALUE: u32 = 0x80AA;
pub const GL_SAMPLE_MASK: u32 = 0x8E51;
pub const GL_SAMPLE_MASK_VALUE: u32 = 0x8E52;
pub const GL_SAMPLE_POSITION: u32 = 0x8E50;
pub const GL_SCISSOR_BOX: u32 = 0x0C10;
pub const GL_SCISSOR_TEST: u32 = 0x0C11;
pub const GL_SEPARATE_ATTRIBS: u32 = 0x8C8D;
pub const GL_SHADER_BINARY_FORMATS: u32 = 0x8DF8;
pub const GL_SHADER_COMPILER: u32 = 0x8DFA;
pub const GL_SHADER_IMAGE_ACCESS_BARRIER_BIT: u32 = 0x00000020;
pub const GL_SHADER_KHR: u32 = 0x82E1;
pub const GL_SHADER_SOURCE_LENGTH: u32 = 0x8B88;
pub const GL_SHADER_STORAGE_BARRIER_BIT: u32 = 0x00002000;
pub const GL_SHADER_STORAGE_BLOCK: u32 = 0x92E6;
pub const GL_SHADER_STORAGE_BUFFER: u32 = 0x90D2;
pub const GL_SHADER_STORAGE_BUFFER_BINDING: u32 = 0x90D3;
pub const GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT: u32 = 0x90DF;
pub const GL_SHADER_STORAGE_BUFFER_SIZE: u32 = 0x90D5;
pub const GL_SHADER_STORAGE_BUFFER_START: u32 = 0x90D4;
pub const GL_SHADER_TYPE: u32 = 0x8B4F;
pub const GL_SHADING_LANGUAGE_VERSION: u32 = 0x8B8C;
pub const GL_SHORT: u32 = 0x1402;
pub const GL_SIGNALED: u32 = 0x9119;
pub const GL_SIGNED_NORMALIZED: u32 = 0x8F9C;
pub const GL_SRC_ALPHA: u32 = 0x0302;
pub const GL_SRC_ALPHA_SATURATE: u32 = 0x0308;
pub const GL_SRC_COLOR: u32 = 0x0300;
pub const GL_SRGB: u32 = 0x8C40;
pub const GL_SRGB8: u32 = 0x8C41;
pub const GL_SRGB8_ALPHA8: u32 = 0x8C43;
pub const GL_STACK_OVERFLOW_KHR: u32 = 0x0503;
pub const GL_STACK_UNDERFLOW_KHR: u32 = 0x0504;
pub const GL_STATIC_COPY: u32 = 0x88E6;
pub const GL_STATIC_DRAW: u32 = 0x88E4;
pub const GL_STATIC_READ: u32 = 0x88E5;
pub const GL_STENCIL: u32 = 0x1802;
pub const GL_STENCIL_ATTACHMENT: u32 = 0x8D20;
pub const GL_STENCIL_BACK_FAIL: u32 = 0x8801;
pub const GL_STENCIL_BACK_FUNC: u32 = 0x8800;
pub const GL_STENCIL_BACK_PASS_DEPTH_FAIL: u32 = 0x8802;
pub const GL_STENCIL_BACK_PASS_DEPTH_PASS: u32 = 0x8803;
pub const GL_STENCIL_BACK_REF: u32 = 0x8CA3;
pub const GL_STENCIL_BACK_VALUE_MASK: u32 = 0x8CA4;
pub const GL_STENCIL_BACK_WRITEMASK: u32 = 0x8CA5;
pub const GL_STENCIL_BITS: u32 = 0x0D57;
pub const GL_STENCIL_BUFFER_BIT: u32 = 0x00000400;
pub const GL_STENCIL_CLEAR_VALUE: u32 = 0x0B91;
pub const GL_STENCIL_FAIL: u32 = 0x0B94;
pub const GL_STENCIL_FUNC: u32 = 0x0B92;
pub const GL_STENCIL_INDEX: u32 = 0x1901;
pub const GL_STENCIL_INDEX8: u32 = 0x8D48;
pub const GL_STENCIL_PASS_DEPTH_FAIL: u32 = 0x0B95;
pub const GL_STENCIL_PASS_DEPTH_PASS: u32 = 0x0B96;
pub const GL_STENCIL_REF: u32 = 0x0B97;
pub const GL_STENCIL_TEST: u32 = 0x0B90;
pub const GL_STENCIL_VALUE_MASK: u32 = 0x0B93;
pub const GL_STENCIL_WRITEMASK: u32 = 0x0B98;
pub const GL_STREAM_COPY: u32 = 0x88E2;
pub const GL_STREAM_DRAW: u32 = 0x88E0;
pub const GL_STREAM_READ: u32 = 0x88E1;
pub const GL_SUBPIXEL_BITS: u32 = 0x0D50;
pub const GL_SYNC_CONDITION: u32 = 0x9113;
pub const GL_SYNC_FENCE: u32 = 0x9116;
pub const GL_SYNC_FLAGS: u32 = 0x9115;
pub const GL_SYNC_FLUSH_COMMANDS_BIT: u32 = 0x00000001;
pub const GL_SYNC_GPU_COMMANDS_COMPLETE: u32 = 0x9117;
pub const GL_SYNC_STATUS: u32 = 0x9114;
pub const GL_TEXTURE: u32 = 0x1702;
pub const GL_TEXTURE0: u32 = 0x84C0;
pub const GL_TEXTURE1: u32 = 0x84C1;
pub const GL_TEXTURE10: u32 = 0x84CA;
pub const GL_TEXTURE11: u32 = 0x84CB;
pub const GL_TEXTURE12: u32 = 0x84CC;
pub const GL_TEXTURE13: u32 = 0x84CD;
pub const GL_TEXTURE14: u32 = 0x84CE;
pub const GL_TEXTURE15: u32 = 0x84CF;
pub const GL_TEXTURE16: u32 = 0x84D0;
pub const GL_TEXTURE17: u32 = 0x84D1;
pub const GL_TEXTURE18: u32 = 0x84D2;
pub const GL_TEXTURE19: u32 = 0x84D3;
pub const GL_TEXTURE2: u32 = 0x84C2;
pub const GL_TEXTURE20: u32 = 0x84D4;
pub const GL_TEXTURE21: u32 = 0x84D5;
pub const GL_TEXTURE22: u32 = 0x84D6;
pub const GL_TEXTURE23: u32 = 0x84D7;
pub const GL_TEXTURE24: u32 = 0x84D8;
pub const GL_TEXTURE25: u32 = 0x84D9;
pub const GL_TEXTURE26: u32 = 0x84DA;
pub const GL_TEXTURE27: u32 = 0x84DB;
pub const GL_TEXTURE28: u32 = 0x84DC;
pub const GL_TEXTURE29: u32 = 0x84DD;
pub const GL_TEXTURE3: u32 = 0x84C3;
pub const GL_TEXTURE30: u32 = 0x84DE;
pub const GL_TEXTURE31: u32 = 0x84DF;
pub const GL_TEXTURE4: u32 = 0x84C4;
pub const GL_TEXTURE5: u32 = 0x84C5;
pub const GL_TEXTURE6: u32 = 0x84C6;
pub const GL_TEXTURE7: u32 = 0x84C7;
pub const GL_TEXTURE8: u32 = 0x84C8;
pub const GL_TEXTURE9: u32 = 0x84C9;
pub const GL_TEXTURE_2D: u32 = 0x0DE1;
pub const GL_TEXTURE_2D_ARRAY: u32 = 0x8C1A;
pub const GL_TEXTURE_2D_MULTISAMPLE: u32 = 0x9100;
pub const GL_TEXTURE_3D: u32 = 0x806F;
pub const GL_TEXTURE_ALPHA_SIZE: u32 = 0x805F;
pub const GL_TEXTURE_ALPHA_TYPE: u32 = 0x8C13;
pub const GL_TEXTURE_BASE_LEVEL: u32 = 0x813C;
pub const GL_TEXTURE_BINDING_2D: u32 = 0x8069;
pub const GL_TEXTURE_BINDING_2D_ARRAY: u32 = 0x8C1D;
pub const GL_TEXTURE_BINDING_2D_MULTISAMPLE: u32 = 0x9104;
pub const GL_TEXTURE_BINDING_3D: u32 = 0x806A;
pub const GL_TEXTURE_BINDING_CUBE_MAP: u32 = 0x8514;
pub const GL_TEXTURE_BLUE_SIZE: u32 = 0x805E;
pub const GL_TEXTURE_BLUE_TYPE: u32 = 0x8C12;
pub const GL_TEXTURE_COMPARE_FUNC: u32 = 0x884D;
pub const GL_TEXTURE_COMPARE_MODE: u32 = 0x884C;
pub const GL_TEXTURE_COMPRESSED: u32 = 0x86A1;
pub const GL_TEXTURE_CUBE_MAP: u32 = 0x8513;
pub const GL_TEXTURE_CUBE_MAP_NEGATIVE_X: u32 = 0x8516;
pub const GL_TEXTURE_CUBE_MAP_NEGATIVE_Y: u32 = 0x8518;
pub const GL_TEXTURE_CUBE_MAP_NEGATIVE_Z: u32 = 0x851A;
pub const GL_TEXTURE_CUBE_MAP_POSITIVE_X: u32 = 0x8515;
pub const GL_TEXTURE_CUBE_MAP_POSITIVE_Y: u32 = 0x8517;
pub const GL_TEXTURE_CUBE_MAP_POSITIVE_Z: u32 = 0x8519;
pub const GL_TEXTURE_DEPTH: u32 = 0x8071;
pub const GL_TEXTURE_DEPTH_SIZE: u32 = 0x884A;
pub const GL_TEXTURE_DEPTH_TYPE: u32 = 0x8C16;
pub const GL_TEXTURE_FETCH_BARRIER_BIT: u32 = 0x00000008;
pub const GL_TEXTURE_FIXED_SAMPLE_LOCATIONS: u32 = 0x9107;
pub const GL_TEXTURE_GREEN_SIZE: u32 = 0x805D;
pub const GL_TEXTURE_GREEN_TYPE: u32 = 0x8C11;
pub const GL_TEXTURE_HEIGHT: u32 = 0x1001;
pub const GL_TEXTURE_IMMUTABLE_FORMAT: u32 = 0x912F;
pub const GL_TEXTURE_IMMUTABLE_LEVELS: u32 = 0x82DF;
pub const GL_TEXTURE_INTERNAL_FORMAT: u32 = 0x1003;
pub const GL_TEXTURE_MAG_FILTER: u32 = 0x2800;
pub const GL_TEXTURE_MAX_LEVEL: u32 = 0x813D;
pub const GL_TEXTURE_MAX_LOD: u32 = 0x813B;
pub const GL_TEXTURE_MIN_FILTER: u32 = 0x2801;
pub const GL_TEXTURE_MIN_LOD: u32 = 0x813A;
pub const GL_TEXTURE_RED_SIZE: u32 = 0x805C;
pub const GL_TEXTURE_RED_TYPE: u32 = 0x8C10;
pub const GL_TEXTURE_SAMPLES: u32 = 0x9106;
pub const GL_TEXTURE_SHARED_SIZE: u32 = 0x8C3F;
pub const GL_TEXTURE_STENCIL_SIZE: u32 = 0x88F1;
pub const GL_TEXTURE_SWIZZLE_A: u32 = 0x8E45;
pub const GL_TEXTURE_SWIZZLE_B: u32 = 0x8E44;
pub const GL_TEXTURE_SWIZZLE_G: u32 = 0x8E43;
pub const GL_TEXTURE_SWIZZLE_R: u32 = 0x8E42;
pub const GL_TEXTURE_UPDATE_BARRIER_BIT: u32 = 0x00000100;
pub const GL_TEXTURE_WIDTH: u32 = 0x1000;
pub const GL_TEXTURE_WRAP_R: u32 = 0x8072;
pub const GL_TEXTURE_WRAP_S: u32 = 0x2802;
pub const GL_TEXTURE_WRAP_T: u32 = 0x2803;
pub const GL_TIMEOUT_EXPIRED: u32 = 0x911B;
pub const GL_TIMEOUT_IGNORED: u64 = 0xFFFFFFFFFFFFFFFF;
pub const GL_TOP_LEVEL_ARRAY_SIZE: u32 = 0x930C;
pub const GL_TOP_LEVEL_ARRAY_STRIDE: u32 = 0x930D;
pub const GL_TRANSFORM_FEEDBACK: u32 = 0x8E22;
pub const GL_TRANSFORM_FEEDBACK_ACTIVE: u32 = 0x8E24;
pub const GL_TRANSFORM_FEEDBACK_BARRIER_BIT: u32 = 0x00000800;
pub const GL_TRANSFORM_FEEDBACK_BINDING: u32 = 0x8E25;
pub const GL_TRANSFORM_FEEDBACK_BUFFER: u32 = 0x8C8E;
pub const GL_TRANSFORM_FEEDBACK_BUFFER_BINDING: u32 = 0x8C8F;
pub const GL_TRANSFORM_FEEDBACK_BUFFER_MODE: u32 = 0x8C7F;
pub const GL_TRANSFORM_FEEDBACK_BUFFER_SIZE: u32 = 0x8C85;
pub const GL_TRANSFORM_FEEDBACK_BUFFER_START: u32 = 0x8C84;
pub const GL_TRANSFORM_FEEDBACK_PAUSED: u32 = 0x8E23;
pub const GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: u32 = 0x8C88;
pub const GL_TRANSFORM_FEEDBACK_VARYING: u32 = 0x92F4;
pub const GL_TRANSFORM_FEEDBACK_VARYINGS: u32 = 0x8C83;
pub const GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH: u32 = 0x8C76;
pub const GL_TRIANGLES: u32 = 0x0004;
pub const GL_TRIANGLE_FAN: u32 = 0x0006;
pub const GL_TRIANGLE_STRIP: u32 = 0x0005;
pub const GL_TRUE: u32 = 1;
pub const GL_TYPE: u32 = 0x92FA;
pub const GL_UNIFORM: u32 = 0x92E1;
pub const GL_UNIFORM_ARRAY_STRIDE: u32 = 0x8A3C;
pub const GL_UNIFORM_BARRIER_BIT: u32 = 0x00000004;
pub const GL_UNIFORM_BLOCK: u32 = 0x92E2;
pub const GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS: u32 = 0x8A42;
pub const GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: u32 = 0x8A43;
pub const GL_UNIFORM_BLOCK_BINDING: u32 = 0x8A3F;
pub const GL_UNIFORM_BLOCK_DATA_SIZE: u32 = 0x8A40;
pub const GL_UNIFORM_BLOCK_INDEX: u32 = 0x8A3A;
pub const GL_UNIFORM_BLOCK_NAME_LENGTH: u32 = 0x8A41;
pub const GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: u32 = 0x8A46;
pub const GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: u32 = 0x8A44;
pub const GL_UNIFORM_BUFFER: u32 = 0x8A11;
pub const GL_UNIFORM_BUFFER_BINDING: u32 = 0x8A28;
pub const GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT: u32 = 0x8A34;
pub const GL_UNIFORM_BUFFER_SIZE: u32 = 0x8A2A;
pub const GL_UNIFORM_BUFFER_START: u32 = 0x8A29;
pub const GL_UNIFORM_IS_ROW_MAJOR: u32 = 0x8A3E;
pub const GL_UNIFORM_MATRIX_STRIDE: u32 = 0x8A3D;
pub const GL_UNIFORM_NAME_LENGTH: u32 = 0x8A39;
pub const GL_UNIFORM_OFFSET: u32 = 0x8A3B;
pub const GL_UNIFORM_SIZE: u32 = 0x8A38;
pub const GL_UNIFORM_TYPE: u32 = 0x8A37;
pub const GL_UNPACK_ALIGNMENT: u32 = 0x0CF5;
pub const GL_UNPACK_IMAGE_HEIGHT: u32 = 0x806E;
pub const GL_UNPACK_ROW_LENGTH: u32 = 0x0CF2;
pub const GL_UNPACK_SKIP_IMAGES: u32 = 0x806D;
pub const GL_UNPACK_SKIP_PIXELS: u32 = 0x0CF4;
pub const GL_UNPACK_SKIP_ROWS: u32 = 0x0CF3;
pub const GL_UNSIGNALED: u32 = 0x9118;
pub const GL_UNSIGNED_BYTE: u32 = 0x1401;
pub const GL_UNSIGNED_INT: u32 = 0x1405;
pub const GL_UNSIGNED_INT_10F_11F_11F_REV: u32 = 0x8C3B;
pub const GL_UNSIGNED_INT_24_8: u32 = 0x84FA;
pub const GL_UNSIGNED_INT_2_10_10_10_REV: u32 = 0x8368;
pub const GL_UNSIGNED_INT_5_9_9_9_REV: u32 = 0x8C3E;
pub const GL_UNSIGNED_INT_ATOMIC_COUNTER: u32 = 0x92DB;
pub const GL_UNSIGNED_INT_IMAGE_2D: u32 = 0x9063;
pub const GL_UNSIGNED_INT_IMAGE_2D_ARRAY: u32 = 0x9069;
pub const GL_UNSIGNED_INT_IMAGE_3D: u32 = 0x9064;
pub const GL_UNSIGNED_INT_IMAGE_CUBE: u32 = 0x9066;
pub const GL_UNSIGNED_INT_SAMPLER_2D: u32 = 0x8DD2;
pub const GL_UNSIGNED_INT_SAMPLER_2D_ARRAY: u32 = 0x8DD7;
pub const GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE: u32 = 0x910A;
pub const GL_UNSIGNED_INT_SAMPLER_3D: u32 = 0x8DD3;
pub const GL_UNSIGNED_INT_SAMPLER_CUBE: u32 = 0x8DD4;
pub const GL_UNSIGNED_INT_VEC2: u32 = 0x8DC6;
pub const GL_UNSIGNED_INT_VEC3: u32 = 0x8DC7;
pub const GL_UNSIGNED_INT_VEC4: u32 = 0x8DC8;
pub const GL_UNSIGNED_NORMALIZED: u32 = 0x8C17;
pub const GL_UNSIGNED_SHORT: u32 = 0x1403;
pub const GL_UNSIGNED_SHORT_4_4_4_4: u32 = 0x8033;
pub const GL_UNSIGNED_SHORT_5_5_5_1: u32 = 0x8034;
pub const GL_UNSIGNED_SHORT_5_6_5: u32 = 0x8363;
pub const GL_VALIDATE_STATUS: u32 = 0x8B83;
pub const GL_VENDOR: u32 = 0x1F00;
pub const GL_VERSION: u32 = 0x1F02;
pub const GL_VERTEX_ARRAY_BINDING: u32 = 0x85B5;
pub const GL_VERTEX_ARRAY_KHR: u32 = 0x8074;
pub const GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT: u32 = 0x00000001;
pub const GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: u32 = 0x889F;
pub const GL_VERTEX_ATTRIB_ARRAY_DIVISOR: u32 = 0x88FE;
pub const GL_VERTEX_ATTRIB_ARRAY_ENABLED: u32 = 0x8622;
pub const GL_VERTEX_ATTRIB_ARRAY_INTEGER: u32 = 0x88FD;
pub const GL_VERTEX_ATTRIB_ARRAY_NORMALIZED: u32 = 0x886A;
pub const GL_VERTEX_ATTRIB_ARRAY_POINTER: u32 = 0x8645;
pub const GL_VERTEX_ATTRIB_ARRAY_SIZE: u32 = 0x8623;
pub const GL_VERTEX_ATTRIB_ARRAY_STRIDE: u32 = 0x8624;
pub const GL_VERTEX_ATTRIB_ARRAY_TYPE: u32 = 0x8625;
pub const GL_VERTEX_ATTRIB_BINDING: u32 = 0x82D4;
pub const GL_VERTEX_ATTRIB_RELATIVE_OFFSET: u32 = 0x82D5;
pub const GL_VERTEX_BINDING_BUFFER: u32 = 0x8F4F;
pub const GL_VERTEX_BINDING_DIVISOR: u32 = 0x82D6;
pub const GL_VERTEX_BINDING_OFFSET: u32 = 0x82D7;
pub const GL_VERTEX_BINDING_STRIDE: u32 = 0x82D8;
pub const GL_VERTEX_SHADER: u32 = 0x8B31;
pub const GL_VERTEX_SHADER_BIT: u32 = 0x00000001;
pub const GL_VIEWPORT: u32 = 0x0BA2;
pub const GL_WAIT_FAILED: u32 = 0x911D;
pub const GL_WRITE_ONLY: u32 = 0x88B9;
pub const GL_ZERO: u32 = 0;

static glActiveShaderProgram_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glActiveShaderProgram(pipeline: GLuint, program: GLuint) -> () {
  let u: usize = glActiveShaderProgram_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(pipeline, program)
}

static glActiveTexture_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glActiveTexture(texture: GLenum) -> () {
  let u: usize = glActiveTexture_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum) -> () = unsafe { core::mem::transmute(u) };
  _func_p(texture)
}

static glAttachShader_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glAttachShader(program: GLuint, shader: GLuint) -> () {
  let u: usize = glAttachShader_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(program, shader)
}

static glBeginQuery_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glBeginQuery(target: GLenum, id: GLuint) -> () {
  let u: usize = glBeginQuery_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(target, id)
}

static glBeginTransformFeedback_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glBeginTransformFeedback(primitiveMode: GLenum) -> () {
  let u: usize = glBeginTransformFeedback_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum) -> () = unsafe { core::mem::transmute(u) };
  _func_p(primitiveMode)
}

static glBindAttribLocation_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glBindAttribLocation(program: GLuint, index: GLuint, name: *const GLchar) -> () {
  let u: usize = glBindAttribLocation_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLuint, *const GLchar) -> () = unsafe { core::mem::transmute(u) };
  _func_p(program, index, name)
}

static glBindBuffer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glBindBuffer(target: GLenum, buffer: GLuint) -> () {
  let u: usize = glBindBuffer_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(target, buffer)
}

static glBindBufferBase_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glBindBufferBase(target: GLenum, index: GLuint, buffer: GLuint) -> () {
  let u: usize = glBindBufferBase_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLuint, GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(target, index, buffer)
}

static glBindBufferRange_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glBindBufferRange(
  target: GLenum, index: GLuint, buffer: GLuint, offset: GLintptr, size: GLsizeiptr,
) -> () {
  let u: usize = glBindBufferRange_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLuint, GLuint, GLintptr, GLsizeiptr) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(target, index, buffer, offset, size)
}

static glBindFramebuffer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glBindFramebuffer(target: GLenum, framebuffer: GLuint) -> () {
  let u: usize = glBindFramebuffer_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(target, framebuffer)
}

static glBindImageTexture_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glBindImageTexture(
  unit: GLuint, texture: GLuint, level: GLint, layered: GLboolean, layer: GLint, access: GLenum, format: GLenum,
) -> () {
  let u: usize = glBindImageTexture_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLuint, GLint, GLboolean, GLint, GLenum, GLenum) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(unit, texture, level, layered, layer, access, format)
}

static glBindProgramPipeline_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glBindProgramPipeline(pipeline: GLuint) -> () {
  let u: usize = glBindProgramPipeline_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(pipeline)
}

static glBindRenderbuffer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glBindRenderbuffer(target: GLenum, renderbuffer: GLuint) -> () {
  let u: usize = glBindRenderbuffer_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(target, renderbuffer)
}

static glBindSampler_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glBindSampler(unit: GLuint, sampler: GLuint) -> () {
  let u: usize = glBindSampler_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(unit, sampler)
}

static glBindTexture_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glBindTexture(target: GLenum, texture: GLuint) -> () {
  let u: usize = glBindTexture_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(target, texture)
}

static glBindTransformFeedback_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glBindTransformFeedback(target: GLenum, id: GLuint) -> () {
  let u: usize = glBindTransformFeedback_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(target, id)
}

static glBindVertexArray_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glBindVertexArray(array: GLuint) -> () {
  let u: usize = glBindVertexArray_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(array)
}

static glBindVertexBuffer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glBindVertexBuffer(bindingindex: GLuint, buffer: GLuint, offset: GLintptr, stride: GLsizei) -> () {
  let u: usize = glBindVertexBuffer_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLuint, GLintptr, GLsizei) -> () = unsafe { core::mem::transmute(u) };
  _func_p(bindingindex, buffer, offset, stride)
}

static glBlendColor_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glBlendColor(red: GLfloat, green: GLfloat, blue: GLfloat, alpha: GLfloat) -> () {
  let u: usize = glBlendColor_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLfloat, GLfloat, GLfloat, GLfloat) -> () = unsafe { core::mem::transmute(u) };
  _func_p(red, green, blue, alpha)
}

static glBlendEquation_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glBlendEquation(mode: GLenum) -> () {
  let u: usize = glBlendEquation_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum) -> () = unsafe { core::mem::transmute(u) };
  _func_p(mode)
}

static glBlendEquationSeparate_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glBlendEquationSeparate(modeRGB: GLenum, modeAlpha: GLenum) -> () {
  let u: usize = glBlendEquationSeparate_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLenum) -> () = unsafe { core::mem::transmute(u) };
  _func_p(modeRGB, modeAlpha)
}

static glBlendFunc_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glBlendFunc(sfactor: GLenum, dfactor: GLenum) -> () {
  let u: usize = glBlendFunc_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLenum) -> () = unsafe { core::mem::transmute(u) };
  _func_p(sfactor, dfactor)
}

static glBlendFuncSeparate_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glBlendFuncSeparate(
  sfactorRGB: GLenum, dfactorRGB: GLenum, sfactorAlpha: GLenum, dfactorAlpha: GLenum,
) -> () {
  let u: usize = glBlendFuncSeparate_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLenum, GLenum, GLenum) -> () = unsafe { core::mem::transmute(u) };
  _func_p(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha)
}

static glBlitFramebuffer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glBlitFramebuffer(
  srcX0: GLint, srcY0: GLint, srcX1: GLint, srcY1: GLint, dstX0: GLint, dstY0: GLint, dstX1: GLint, dstY1: GLint,
  mask: GLbitfield, filter: GLenum,
) -> () {
  let u: usize = glBlitFramebuffer_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(
    GLint,
    GLint,
    GLint,
    GLint,
    GLint,
    GLint,
    GLint,
    GLint,
    GLbitfield,
    GLenum,
  ) -> () = unsafe { core::mem::transmute(u) };
  _func_p(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter)
}

static glBufferData_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glBufferData(target: GLenum, size: GLsizeiptr, data: *const void, usage: GLenum) -> () {
  let u: usize = glBufferData_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLsizeiptr, *const void, GLenum) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(target, size, data, usage)
}

static glBufferSubData_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glBufferSubData(target: GLenum, offset: GLintptr, size: GLsizeiptr, data: *const void) -> () {
  let u: usize = glBufferSubData_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLintptr, GLsizeiptr, *const void) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(target, offset, size, data)
}

static glCheckFramebufferStatus_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glCheckFramebufferStatus(target: GLenum) -> GLenum {
  let u: usize = glCheckFramebufferStatus_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum) -> GLenum = unsafe { core::mem::transmute(u) };
  _func_p(target)
}

static glClear_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glClear(mask: GLbitfield) -> () {
  let u: usize = glClear_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLbitfield) -> () = unsafe { core::mem::transmute(u) };
  _func_p(mask)
}

static glClearBufferfi_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glClearBufferfi(buffer: GLenum, drawbuffer: GLint, depth: GLfloat, stencil: GLint) -> () {
  let u: usize = glClearBufferfi_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLint, GLfloat, GLint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(buffer, drawbuffer, depth, stencil)
}

static glClearBufferfv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glClearBufferfv(buffer: GLenum, drawbuffer: GLint, value: *const GLfloat) -> () {
  let u: usize = glClearBufferfv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLint, *const GLfloat) -> () = unsafe { core::mem::transmute(u) };
  _func_p(buffer, drawbuffer, value)
}

static glClearBufferiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glClearBufferiv(buffer: GLenum, drawbuffer: GLint, value: *const GLint) -> () {
  let u: usize = glClearBufferiv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLint, *const GLint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(buffer, drawbuffer, value)
}

static glClearBufferuiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glClearBufferuiv(buffer: GLenum, drawbuffer: GLint, value: *const GLuint) -> () {
  let u: usize = glClearBufferuiv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLint, *const GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(buffer, drawbuffer, value)
}

static glClearColor_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glClearColor(red: GLfloat, green: GLfloat, blue: GLfloat, alpha: GLfloat) -> () {
  let u: usize = glClearColor_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLfloat, GLfloat, GLfloat, GLfloat) -> () = unsafe { core::mem::transmute(u) };
  _func_p(red, green, blue, alpha)
}

static glClearDepthf_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glClearDepthf(d: GLfloat) -> () {
  let u: usize = glClearDepthf_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLfloat) -> () = unsafe { core::mem::transmute(u) };
  _func_p(d)
}

static glClearStencil_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glClearStencil(s: GLint) -> () {
  let u: usize = glClearStencil_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(s)
}

static glClientWaitSync_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glClientWaitSync(sync: GLsync, flags: GLbitfield, timeout: GLuint64) -> GLenum {
  let u: usize = glClientWaitSync_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLsync, GLbitfield, GLuint64) -> GLenum = unsafe { core::mem::transmute(u) };
  _func_p(sync, flags, timeout)
}

static glColorMask_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glColorMask(red: GLboolean, green: GLboolean, blue: GLboolean, alpha: GLboolean) -> () {
  let u: usize = glColorMask_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLboolean, GLboolean, GLboolean, GLboolean) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(red, green, blue, alpha)
}

static glCompileShader_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glCompileShader(shader: GLuint) -> () {
  let u: usize = glCompileShader_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(shader)
}

static glCompressedTexImage2D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glCompressedTexImage2D(
  target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, border: GLint,
  imageSize: GLsizei, data: *const void,
) -> () {
  let u: usize = glCompressedTexImage2D_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLint, GLenum, GLsizei, GLsizei, GLint, GLsizei, *const void) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(target, level, internalformat, width, height, border, imageSize, data)
}

static glCompressedTexImage3D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glCompressedTexImage3D(
  target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint,
  imageSize: GLsizei, data: *const void,
) -> () {
  let u: usize = glCompressedTexImage3D_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(
    GLenum,
    GLint,
    GLenum,
    GLsizei,
    GLsizei,
    GLsizei,
    GLint,
    GLsizei,
    *const void,
  ) -> () = unsafe { core::mem::transmute(u) };
  _func_p(target, level, internalformat, width, height, depth, border, imageSize, data)
}

static glCompressedTexSubImage2D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glCompressedTexSubImage2D(
  target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum,
  imageSize: GLsizei, data: *const void,
) -> () {
  let u: usize = glCompressedTexSubImage2D_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(
    GLenum,
    GLint,
    GLint,
    GLint,
    GLsizei,
    GLsizei,
    GLenum,
    GLsizei,
    *const void,
  ) -> () = unsafe { core::mem::transmute(u) };
  _func_p(target, level, xoffset, yoffset, width, height, format, imageSize, data)
}

static glCompressedTexSubImage3D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glCompressedTexSubImage3D(
  target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei,
  depth: GLsizei, format: GLenum, imageSize: GLsizei, data: *const void,
) -> () {
  let u: usize = glCompressedTexSubImage3D_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(
    GLenum,
    GLint,
    GLint,
    GLint,
    GLint,
    GLsizei,
    GLsizei,
    GLsizei,
    GLenum,
    GLsizei,
    *const void,
  ) -> () = unsafe { core::mem::transmute(u) };
  _func_p(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data)
}

static glCopyBufferSubData_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glCopyBufferSubData(
  readTarget: GLenum, writeTarget: GLenum, readOffset: GLintptr, writeOffset: GLintptr, size: GLsizeiptr,
) -> () {
  let u: usize = glCopyBufferSubData_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLenum, GLintptr, GLintptr, GLsizeiptr) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(readTarget, writeTarget, readOffset, writeOffset, size)
}

static glCopyTexImage2D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glCopyTexImage2D(
  target: GLenum, level: GLint, internalformat: GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei,
  border: GLint,
) -> () {
  let u: usize = glCopyTexImage2D_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLsizei, GLint) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(target, level, internalformat, x, y, width, height, border)
}

static glCopyTexSubImage2D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glCopyTexSubImage2D(
  target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei,
) -> () {
  let u: usize = glCopyTexSubImage2D_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(target, level, xoffset, yoffset, x, y, width, height)
}

static glCopyTexSubImage3D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glCopyTexSubImage3D(
  target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, x: GLint, y: GLint, width: GLsizei,
  height: GLsizei,
) -> () {
  let u: usize = glCopyTexSubImage3D_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLint, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(target, level, xoffset, yoffset, zoffset, x, y, width, height)
}

static glCreateProgram_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glCreateProgram() -> GLuint {
  let u: usize = glCreateProgram_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn() -> GLuint = unsafe { core::mem::transmute(u) };
  _func_p()
}

static glCreateShader_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glCreateShader(type_: GLenum) -> GLuint {
  let u: usize = glCreateShader_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum) -> GLuint = unsafe { core::mem::transmute(u) };
  _func_p(type_)
}

static glCreateShaderProgramv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glCreateShaderProgramv(type_: GLenum, count: GLsizei, strings: *const *const GLchar) -> GLuint {
  let u: usize = glCreateShaderProgramv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLsizei, *const *const GLchar) -> GLuint =
    unsafe { core::mem::transmute(u) };
  _func_p(type_, count, strings)
}

static glCullFace_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glCullFace(mode: GLenum) -> () {
  let u: usize = glCullFace_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum) -> () = unsafe { core::mem::transmute(u) };
  _func_p(mode)
}

static glDebugMessageCallbackKHR_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glDebugMessageCallbackKHR(callback: GLDEBUGPROCKHR, userParam: *const void) -> () {
  let u: usize = glDebugMessageCallbackKHR_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLDEBUGPROCKHR, *const void) -> () = unsafe { core::mem::transmute(u) };
  _func_p(callback, userParam)
}

static glDebugMessageControlKHR_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glDebugMessageControlKHR(
  source: GLenum, type_: GLenum, severity: GLenum, count: GLsizei, ids: *const GLuint, enabled: GLboolean,
) -> () {
  let u: usize = glDebugMessageControlKHR_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLenum, GLenum, GLsizei, *const GLuint, GLboolean) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(source, type_, severity, count, ids, enabled)
}

static glDebugMessageInsertKHR_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glDebugMessageInsertKHR(
  source: GLenum, type_: GLenum, id: GLuint, severity: GLenum, length: GLsizei, buf: *const GLchar,
) -> () {
  let u: usize = glDebugMessageInsertKHR_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLenum, GLuint, GLenum, GLsizei, *const GLchar) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(source, type_, id, severity, length, buf)
}

static glDeleteBuffers_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glDeleteBuffers(n: GLsizei, buffers: *const GLuint) -> () {
  let u: usize = glDeleteBuffers_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLsizei, *const GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(n, buffers)
}

static glDeleteFramebuffers_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glDeleteFramebuffers(n: GLsizei, framebuffers: *const GLuint) -> () {
  let u: usize = glDeleteFramebuffers_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLsizei, *const GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(n, framebuffers)
}

static glDeleteProgram_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glDeleteProgram(program: GLuint) -> () {
  let u: usize = glDeleteProgram_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(program)
}

static glDeleteProgramPipelines_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glDeleteProgramPipelines(n: GLsizei, pipelines: *const GLuint) -> () {
  let u: usize = glDeleteProgramPipelines_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLsizei, *const GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(n, pipelines)
}

static glDeleteQueries_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glDeleteQueries(n: GLsizei, ids: *const GLuint) -> () {
  let u: usize = glDeleteQueries_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLsizei, *const GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(n, ids)
}

static glDeleteRenderbuffers_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glDeleteRenderbuffers(n: GLsizei, renderbuffers: *const GLuint) -> () {
  let u: usize = glDeleteRenderbuffers_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLsizei, *const GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(n, renderbuffers)
}

static glDeleteSamplers_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glDeleteSamplers(count: GLsizei, samplers: *const GLuint) -> () {
  let u: usize = glDeleteSamplers_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLsizei, *const GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(count, samplers)
}

static glDeleteShader_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glDeleteShader(shader: GLuint) -> () {
  let u: usize = glDeleteShader_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(shader)
}

static glDeleteSync_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glDeleteSync(sync: GLsync) -> () {
  let u: usize = glDeleteSync_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLsync) -> () = unsafe { core::mem::transmute(u) };
  _func_p(sync)
}

static glDeleteTextures_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glDeleteTextures(n: GLsizei, textures: *const GLuint) -> () {
  let u: usize = glDeleteTextures_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLsizei, *const GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(n, textures)
}

static glDeleteTransformFeedbacks_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glDeleteTransformFeedbacks(n: GLsizei, ids: *const GLuint) -> () {
  let u: usize = glDeleteTransformFeedbacks_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLsizei, *const GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(n, ids)
}

static glDeleteVertexArrays_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glDeleteVertexArrays(n: GLsizei, arrays: *const GLuint) -> () {
  let u: usize = glDeleteVertexArrays_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLsizei, *const GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(n, arrays)
}

static glDepthFunc_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glDepthFunc(func: GLenum) -> () {
  let u: usize = glDepthFunc_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum) -> () = unsafe { core::mem::transmute(u) };
  _func_p(func)
}

static glDepthMask_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glDepthMask(flag: GLboolean) -> () {
  let u: usize = glDepthMask_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLboolean) -> () = unsafe { core::mem::transmute(u) };
  _func_p(flag)
}

static glDepthRangef_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glDepthRangef(n: GLfloat, f: GLfloat) -> () {
  let u: usize = glDepthRangef_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLfloat, GLfloat) -> () = unsafe { core::mem::transmute(u) };
  _func_p(n, f)
}

static glDetachShader_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glDetachShader(program: GLuint, shader: GLuint) -> () {
  let u: usize = glDetachShader_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(program, shader)
}

static glDisable_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glDisable(cap: GLenum) -> () {
  let u: usize = glDisable_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum) -> () = unsafe { core::mem::transmute(u) };
  _func_p(cap)
}

static glDisableVertexAttribArray_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glDisableVertexAttribArray(index: GLuint) -> () {
  let u: usize = glDisableVertexAttribArray_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(index)
}

static glDispatchCompute_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glDispatchCompute(num_groups_x: GLuint, num_groups_y: GLuint, num_groups_z: GLuint) -> () {
  let u: usize = glDispatchCompute_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLuint, GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(num_groups_x, num_groups_y, num_groups_z)
}

static glDispatchComputeIndirect_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glDispatchComputeIndirect(indirect: GLintptr) -> () {
  let u: usize = glDispatchComputeIndirect_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLintptr) -> () = unsafe { core::mem::transmute(u) };
  _func_p(indirect)
}

static glDrawArrays_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glDrawArrays(mode: GLenum, first: GLint, count: GLsizei) -> () {
  let u: usize = glDrawArrays_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLint, GLsizei) -> () = unsafe { core::mem::transmute(u) };
  _func_p(mode, first, count)
}

static glDrawArraysIndirect_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glDrawArraysIndirect(mode: GLenum, indirect: *const void) -> () {
  let u: usize = glDrawArraysIndirect_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, *const void) -> () = unsafe { core::mem::transmute(u) };
  _func_p(mode, indirect)
}

static glDrawArraysInstanced_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glDrawArraysInstanced(mode: GLenum, first: GLint, count: GLsizei, instancecount: GLsizei) -> () {
  let u: usize = glDrawArraysInstanced_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLint, GLsizei, GLsizei) -> () = unsafe { core::mem::transmute(u) };
  _func_p(mode, first, count, instancecount)
}

static glDrawBuffers_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glDrawBuffers(n: GLsizei, bufs: *const GLenum) -> () {
  let u: usize = glDrawBuffers_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLsizei, *const GLenum) -> () = unsafe { core::mem::transmute(u) };
  _func_p(n, bufs)
}

static glDrawElements_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glDrawElements(mode: GLenum, count: GLsizei, type_: GLenum, indices: *const void) -> () {
  let u: usize = glDrawElements_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLsizei, GLenum, *const void) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(mode, count, type_, indices)
}

static glDrawElementsIndirect_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glDrawElementsIndirect(mode: GLenum, type_: GLenum, indirect: *const void) -> () {
  let u: usize = glDrawElementsIndirect_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLenum, *const void) -> () = unsafe { core::mem::transmute(u) };
  _func_p(mode, type_, indirect)
}

static glDrawElementsInstanced_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glDrawElementsInstanced(
  mode: GLenum, count: GLsizei, type_: GLenum, indices: *const void, instancecount: GLsizei,
) -> () {
  let u: usize = glDrawElementsInstanced_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLsizei, GLenum, *const void, GLsizei) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(mode, count, type_, indices, instancecount)
}

static glDrawRangeElements_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glDrawRangeElements(
  mode: GLenum, start: GLuint, end: GLuint, count: GLsizei, type_: GLenum, indices: *const void,
) -> () {
  let u: usize = glDrawRangeElements_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLuint, GLuint, GLsizei, GLenum, *const void) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(mode, start, end, count, type_, indices)
}

static glEnable_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glEnable(cap: GLenum) -> () {
  let u: usize = glEnable_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum) -> () = unsafe { core::mem::transmute(u) };
  _func_p(cap)
}

static glEnableVertexAttribArray_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glEnableVertexAttribArray(index: GLuint) -> () {
  let u: usize = glEnableVertexAttribArray_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(index)
}

static glEndQuery_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glEndQuery(target: GLenum) -> () {
  let u: usize = glEndQuery_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum) -> () = unsafe { core::mem::transmute(u) };
  _func_p(target)
}

static glEndTransformFeedback_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glEndTransformFeedback() -> () {
  let u: usize = glEndTransformFeedback_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn() -> () = unsafe { core::mem::transmute(u) };
  _func_p()
}

static glFenceSync_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glFenceSync(condition: GLenum, flags: GLbitfield) -> GLsync {
  let u: usize = glFenceSync_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLbitfield) -> GLsync = unsafe { core::mem::transmute(u) };
  _func_p(condition, flags)
}

static glFinish_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glFinish() -> () {
  let u: usize = glFinish_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn() -> () = unsafe { core::mem::transmute(u) };
  _func_p()
}

static glFlush_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glFlush() -> () {
  let u: usize = glFlush_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn() -> () = unsafe { core::mem::transmute(u) };
  _func_p()
}

static glFlushMappedBufferRange_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glFlushMappedBufferRange(target: GLenum, offset: GLintptr, length: GLsizeiptr) -> () {
  let u: usize = glFlushMappedBufferRange_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLintptr, GLsizeiptr) -> () = unsafe { core::mem::transmute(u) };
  _func_p(target, offset, length)
}

static glFramebufferParameteri_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glFramebufferParameteri(target: GLenum, pname: GLenum, param: GLint) -> () {
  let u: usize = glFramebufferParameteri_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLenum, GLint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(target, pname, param)
}

static glFramebufferRenderbuffer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glFramebufferRenderbuffer(
  target: GLenum, attachment: GLenum, renderbuffertarget: GLenum, renderbuffer: GLuint,
) -> () {
  let u: usize = glFramebufferRenderbuffer_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLenum, GLenum, GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(target, attachment, renderbuffertarget, renderbuffer)
}

static glFramebufferTexture2D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glFramebufferTexture2D(
  target: GLenum, attachment: GLenum, textarget: GLenum, texture: GLuint, level: GLint,
) -> () {
  let u: usize = glFramebufferTexture2D_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLenum, GLenum, GLuint, GLint) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(target, attachment, textarget, texture, level)
}

static glFramebufferTextureLayer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glFramebufferTextureLayer(
  target: GLenum, attachment: GLenum, texture: GLuint, level: GLint, layer: GLint,
) -> () {
  let u: usize = glFramebufferTextureLayer_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLenum, GLuint, GLint, GLint) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(target, attachment, texture, level, layer)
}

static glFrontFace_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glFrontFace(mode: GLenum) -> () {
  let u: usize = glFrontFace_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum) -> () = unsafe { core::mem::transmute(u) };
  _func_p(mode)
}

static glGenBuffers_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGenBuffers(n: GLsizei, buffers: *mut GLuint) -> () {
  let u: usize = glGenBuffers_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLsizei, *mut GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(n, buffers)
}

static glGenFramebuffers_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGenFramebuffers(n: GLsizei, framebuffers: *mut GLuint) -> () {
  let u: usize = glGenFramebuffers_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLsizei, *mut GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(n, framebuffers)
}

static glGenProgramPipelines_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGenProgramPipelines(n: GLsizei, pipelines: *mut GLuint) -> () {
  let u: usize = glGenProgramPipelines_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLsizei, *mut GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(n, pipelines)
}

static glGenQueries_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGenQueries(n: GLsizei, ids: *mut GLuint) -> () {
  let u: usize = glGenQueries_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLsizei, *mut GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(n, ids)
}

static glGenRenderbuffers_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGenRenderbuffers(n: GLsizei, renderbuffers: *mut GLuint) -> () {
  let u: usize = glGenRenderbuffers_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLsizei, *mut GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(n, renderbuffers)
}

static glGenSamplers_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGenSamplers(count: GLsizei, samplers: *mut GLuint) -> () {
  let u: usize = glGenSamplers_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLsizei, *mut GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(count, samplers)
}

static glGenTextures_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGenTextures(n: GLsizei, textures: *mut GLuint) -> () {
  let u: usize = glGenTextures_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLsizei, *mut GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(n, textures)
}

static glGenTransformFeedbacks_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGenTransformFeedbacks(n: GLsizei, ids: *mut GLuint) -> () {
  let u: usize = glGenTransformFeedbacks_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLsizei, *mut GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(n, ids)
}

static glGenVertexArrays_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGenVertexArrays(n: GLsizei, arrays: *mut GLuint) -> () {
  let u: usize = glGenVertexArrays_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLsizei, *mut GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(n, arrays)
}

static glGenerateMipmap_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGenerateMipmap(target: GLenum) -> () {
  let u: usize = glGenerateMipmap_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum) -> () = unsafe { core::mem::transmute(u) };
  _func_p(target)
}

static glGetActiveAttrib_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetActiveAttrib(
  program: GLuint, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, size: *mut GLint, type_: *mut GLenum,
  name: *mut GLchar,
) -> () {
  let u: usize = glGetActiveAttrib_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(
    GLuint,
    GLuint,
    GLsizei,
    *mut GLsizei,
    *mut GLint,
    *mut GLenum,
    *mut GLchar,
  ) -> () = unsafe { core::mem::transmute(u) };
  _func_p(program, index, bufSize, length, size, type_, name)
}

static glGetActiveUniform_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetActiveUniform(
  program: GLuint, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, size: *mut GLint, type_: *mut GLenum,
  name: *mut GLchar,
) -> () {
  let u: usize = glGetActiveUniform_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(
    GLuint,
    GLuint,
    GLsizei,
    *mut GLsizei,
    *mut GLint,
    *mut GLenum,
    *mut GLchar,
  ) -> () = unsafe { core::mem::transmute(u) };
  _func_p(program, index, bufSize, length, size, type_, name)
}

static glGetActiveUniformBlockName_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetActiveUniformBlockName(
  program: GLuint, uniformBlockIndex: GLuint, bufSize: GLsizei, length: *mut GLsizei, uniformBlockName: *mut GLchar,
) -> () {
  let u: usize = glGetActiveUniformBlockName_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLuint, GLsizei, *mut GLsizei, *mut GLchar) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(program, uniformBlockIndex, bufSize, length, uniformBlockName)
}

static glGetActiveUniformBlockiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetActiveUniformBlockiv(
  program: GLuint, uniformBlockIndex: GLuint, pname: GLenum, params: *mut GLint,
) -> () {
  let u: usize = glGetActiveUniformBlockiv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLuint, GLenum, *mut GLint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(program, uniformBlockIndex, pname, params)
}

static glGetActiveUniformsiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetActiveUniformsiv(
  program: GLuint, uniformCount: GLsizei, uniformIndices: *const GLuint, pname: GLenum, params: *mut GLint,
) -> () {
  let u: usize = glGetActiveUniformsiv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLsizei, *const GLuint, GLenum, *mut GLint) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(program, uniformCount, uniformIndices, pname, params)
}

static glGetAttachedShaders_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetAttachedShaders(
  program: GLuint, maxCount: GLsizei, count: *mut GLsizei, shaders: *mut GLuint,
) -> () {
  let u: usize = glGetAttachedShaders_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLsizei, *mut GLsizei, *mut GLuint) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(program, maxCount, count, shaders)
}

static glGetAttribLocation_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetAttribLocation(program: GLuint, name: *const GLchar) -> GLint {
  let u: usize = glGetAttribLocation_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, *const GLchar) -> GLint = unsafe { core::mem::transmute(u) };
  _func_p(program, name)
}

static glGetBooleani_v_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetBooleani_v(target: GLenum, index: GLuint, data: *mut GLboolean) -> () {
  let u: usize = glGetBooleani_v_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLuint, *mut GLboolean) -> () = unsafe { core::mem::transmute(u) };
  _func_p(target, index, data)
}

static glGetBooleanv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetBooleanv(pname: GLenum, data: *mut GLboolean) -> () {
  let u: usize = glGetBooleanv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, *mut GLboolean) -> () = unsafe { core::mem::transmute(u) };
  _func_p(pname, data)
}

static glGetBufferParameteri64v_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetBufferParameteri64v(target: GLenum, pname: GLenum, params: *mut GLint64) -> () {
  let u: usize = glGetBufferParameteri64v_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLenum, *mut GLint64) -> () = unsafe { core::mem::transmute(u) };
  _func_p(target, pname, params)
}

static glGetBufferParameteriv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetBufferParameteriv(target: GLenum, pname: GLenum, params: *mut GLint) -> () {
  let u: usize = glGetBufferParameteriv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLenum, *mut GLint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(target, pname, params)
}

static glGetBufferPointerv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetBufferPointerv(target: GLenum, pname: GLenum, params: *mut *mut void) -> () {
  let u: usize = glGetBufferPointerv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLenum, *mut *mut void) -> () = unsafe { core::mem::transmute(u) };
  _func_p(target, pname, params)
}

static glGetDebugMessageLogKHR_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetDebugMessageLogKHR(
  count: GLuint, bufSize: GLsizei, sources: *mut GLenum, types: *mut GLenum, ids: *mut GLuint, severities: *mut GLenum,
  lengths: *mut GLsizei, messageLog: *mut GLchar,
) -> GLuint {
  let u: usize = glGetDebugMessageLogKHR_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(
    GLuint,
    GLsizei,
    *mut GLenum,
    *mut GLenum,
    *mut GLuint,
    *mut GLenum,
    *mut GLsizei,
    *mut GLchar,
  ) -> GLuint = unsafe { core::mem::transmute(u) };
  _func_p(count, bufSize, sources, types, ids, severities, lengths, messageLog)
}

static glGetError_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetError() -> GLenum {
  let u: usize = glGetError_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn() -> GLenum = unsafe { core::mem::transmute(u) };
  _func_p()
}

static glGetFloatv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetFloatv(pname: GLenum, data: *mut GLfloat) -> () {
  let u: usize = glGetFloatv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, *mut GLfloat) -> () = unsafe { core::mem::transmute(u) };
  _func_p(pname, data)
}

static glGetFragDataLocation_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetFragDataLocation(program: GLuint, name: *const GLchar) -> GLint {
  let u: usize = glGetFragDataLocation_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, *const GLchar) -> GLint = unsafe { core::mem::transmute(u) };
  _func_p(program, name)
}

static glGetFramebufferAttachmentParameteriv_p: core::sync::atomic::AtomicUsize =
  core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetFramebufferAttachmentParameteriv(
  target: GLenum, attachment: GLenum, pname: GLenum, params: *mut GLint,
) -> () {
  let u: usize = glGetFramebufferAttachmentParameteriv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLenum, GLenum, *mut GLint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(target, attachment, pname, params)
}

static glGetFramebufferParameteriv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetFramebufferParameteriv(target: GLenum, pname: GLenum, params: *mut GLint) -> () {
  let u: usize = glGetFramebufferParameteriv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLenum, *mut GLint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(target, pname, params)
}

static glGetInteger64i_v_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetInteger64i_v(target: GLenum, index: GLuint, data: *mut GLint64) -> () {
  let u: usize = glGetInteger64i_v_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLuint, *mut GLint64) -> () = unsafe { core::mem::transmute(u) };
  _func_p(target, index, data)
}

static glGetInteger64v_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetInteger64v(pname: GLenum, data: *mut GLint64) -> () {
  let u: usize = glGetInteger64v_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, *mut GLint64) -> () = unsafe { core::mem::transmute(u) };
  _func_p(pname, data)
}

static glGetIntegeri_v_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetIntegeri_v(target: GLenum, index: GLuint, data: *mut GLint) -> () {
  let u: usize = glGetIntegeri_v_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLuint, *mut GLint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(target, index, data)
}

static glGetIntegerv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetIntegerv(pname: GLenum, data: *mut GLint) -> () {
  let u: usize = glGetIntegerv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, *mut GLint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(pname, data)
}

static glGetInternalformativ_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetInternalformativ(
  target: GLenum, internalformat: GLenum, pname: GLenum, count: GLsizei, params: *mut GLint,
) -> () {
  let u: usize = glGetInternalformativ_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLenum, GLenum, GLsizei, *mut GLint) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(target, internalformat, pname, count, params)
}

static glGetMultisamplefv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetMultisamplefv(pname: GLenum, index: GLuint, val: *mut GLfloat) -> () {
  let u: usize = glGetMultisamplefv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLuint, *mut GLfloat) -> () = unsafe { core::mem::transmute(u) };
  _func_p(pname, index, val)
}

static glGetObjectLabelKHR_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetObjectLabelKHR(
  identifier: GLenum, name: GLuint, bufSize: GLsizei, length: *mut GLsizei, label: *mut GLchar,
) -> () {
  let u: usize = glGetObjectLabelKHR_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLuint, GLsizei, *mut GLsizei, *mut GLchar) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(identifier, name, bufSize, length, label)
}

static glGetObjectPtrLabelKHR_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetObjectPtrLabelKHR(
  ptr: *const void, bufSize: GLsizei, length: *mut GLsizei, label: *mut GLchar,
) -> () {
  let u: usize = glGetObjectPtrLabelKHR_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(*const void, GLsizei, *mut GLsizei, *mut GLchar) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(ptr, bufSize, length, label)
}

static glGetPointervKHR_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetPointervKHR(pname: GLenum, params: *mut *mut void) -> () {
  let u: usize = glGetPointervKHR_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, *mut *mut void) -> () = unsafe { core::mem::transmute(u) };
  _func_p(pname, params)
}

static glGetProgramBinary_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetProgramBinary(
  program: GLuint, bufSize: GLsizei, length: *mut GLsizei, binaryFormat: *mut GLenum, binary: *mut void,
) -> () {
  let u: usize = glGetProgramBinary_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLsizei, *mut GLsizei, *mut GLenum, *mut void) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(program, bufSize, length, binaryFormat, binary)
}

static glGetProgramInfoLog_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetProgramInfoLog(program: GLuint, bufSize: GLsizei, length: *mut GLsizei, infoLog: *mut GLchar) -> () {
  let u: usize = glGetProgramInfoLog_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLsizei, *mut GLsizei, *mut GLchar) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(program, bufSize, length, infoLog)
}

static glGetProgramInterfaceiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetProgramInterfaceiv(
  program: GLuint, programInterface: GLenum, pname: GLenum, params: *mut GLint,
) -> () {
  let u: usize = glGetProgramInterfaceiv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLenum, GLenum, *mut GLint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(program, programInterface, pname, params)
}

static glGetProgramPipelineInfoLog_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetProgramPipelineInfoLog(
  pipeline: GLuint, bufSize: GLsizei, length: *mut GLsizei, infoLog: *mut GLchar,
) -> () {
  let u: usize = glGetProgramPipelineInfoLog_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLsizei, *mut GLsizei, *mut GLchar) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(pipeline, bufSize, length, infoLog)
}

static glGetProgramPipelineiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetProgramPipelineiv(pipeline: GLuint, pname: GLenum, params: *mut GLint) -> () {
  let u: usize = glGetProgramPipelineiv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLenum, *mut GLint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(pipeline, pname, params)
}

static glGetProgramResourceIndex_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetProgramResourceIndex(program: GLuint, programInterface: GLenum, name: *const GLchar) -> GLuint {
  let u: usize = glGetProgramResourceIndex_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLenum, *const GLchar) -> GLuint = unsafe { core::mem::transmute(u) };
  _func_p(program, programInterface, name)
}

static glGetProgramResourceLocation_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetProgramResourceLocation(program: GLuint, programInterface: GLenum, name: *const GLchar) -> GLint {
  let u: usize = glGetProgramResourceLocation_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLenum, *const GLchar) -> GLint = unsafe { core::mem::transmute(u) };
  _func_p(program, programInterface, name)
}

static glGetProgramResourceName_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetProgramResourceName(
  program: GLuint, programInterface: GLenum, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, name: *mut GLchar,
) -> () {
  let u: usize = glGetProgramResourceName_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLenum, GLuint, GLsizei, *mut GLsizei, *mut GLchar) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(program, programInterface, index, bufSize, length, name)
}

static glGetProgramResourceiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetProgramResourceiv(
  program: GLuint, programInterface: GLenum, index: GLuint, propCount: GLsizei, props: *const GLenum, count: GLsizei,
  length: *mut GLsizei, params: *mut GLint,
) -> () {
  let u: usize = glGetProgramResourceiv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(
    GLuint,
    GLenum,
    GLuint,
    GLsizei,
    *const GLenum,
    GLsizei,
    *mut GLsizei,
    *mut GLint,
  ) -> () = unsafe { core::mem::transmute(u) };
  _func_p(program, programInterface, index, propCount, props, count, length, params)
}

static glGetProgramiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetProgramiv(program: GLuint, pname: GLenum, params: *mut GLint) -> () {
  let u: usize = glGetProgramiv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLenum, *mut GLint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(program, pname, params)
}

static glGetQueryObjectuiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetQueryObjectuiv(id: GLuint, pname: GLenum, params: *mut GLuint) -> () {
  let u: usize = glGetQueryObjectuiv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLenum, *mut GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(id, pname, params)
}

static glGetQueryiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetQueryiv(target: GLenum, pname: GLenum, params: *mut GLint) -> () {
  let u: usize = glGetQueryiv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLenum, *mut GLint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(target, pname, params)
}

static glGetRenderbufferParameteriv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetRenderbufferParameteriv(target: GLenum, pname: GLenum, params: *mut GLint) -> () {
  let u: usize = glGetRenderbufferParameteriv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLenum, *mut GLint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(target, pname, params)
}

static glGetSamplerParameterfv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetSamplerParameterfv(sampler: GLuint, pname: GLenum, params: *mut GLfloat) -> () {
  let u: usize = glGetSamplerParameterfv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLenum, *mut GLfloat) -> () = unsafe { core::mem::transmute(u) };
  _func_p(sampler, pname, params)
}

static glGetSamplerParameteriv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetSamplerParameteriv(sampler: GLuint, pname: GLenum, params: *mut GLint) -> () {
  let u: usize = glGetSamplerParameteriv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLenum, *mut GLint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(sampler, pname, params)
}

static glGetShaderInfoLog_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetShaderInfoLog(shader: GLuint, bufSize: GLsizei, length: *mut GLsizei, infoLog: *mut GLchar) -> () {
  let u: usize = glGetShaderInfoLog_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLsizei, *mut GLsizei, *mut GLchar) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(shader, bufSize, length, infoLog)
}

static glGetShaderPrecisionFormat_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetShaderPrecisionFormat(
  shadertype: GLenum, precisiontype: GLenum, range: *mut GLint, precision: *mut GLint,
) -> () {
  let u: usize = glGetShaderPrecisionFormat_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLenum, *mut GLint, *mut GLint) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(shadertype, precisiontype, range, precision)
}

static glGetShaderSource_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetShaderSource(shader: GLuint, bufSize: GLsizei, length: *mut GLsizei, source: *mut GLchar) -> () {
  let u: usize = glGetShaderSource_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLsizei, *mut GLsizei, *mut GLchar) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(shader, bufSize, length, source)
}

static glGetShaderiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetShaderiv(shader: GLuint, pname: GLenum, params: *mut GLint) -> () {
  let u: usize = glGetShaderiv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLenum, *mut GLint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(shader, pname, params)
}

static glGetString_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetString(name: GLenum) -> *const GLubyte {
  let u: usize = glGetString_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum) -> *const GLubyte = unsafe { core::mem::transmute(u) };
  _func_p(name)
}

static glGetStringi_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetStringi(name: GLenum, index: GLuint) -> *const GLubyte {
  let u: usize = glGetStringi_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLuint) -> *const GLubyte = unsafe { core::mem::transmute(u) };
  _func_p(name, index)
}

static glGetSynciv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetSynciv(sync: GLsync, pname: GLenum, count: GLsizei, length: *mut GLsizei, values: *mut GLint) -> () {
  let u: usize = glGetSynciv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLsync, GLenum, GLsizei, *mut GLsizei, *mut GLint) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(sync, pname, count, length, values)
}

static glGetTexLevelParameterfv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetTexLevelParameterfv(target: GLenum, level: GLint, pname: GLenum, params: *mut GLfloat) -> () {
  let u: usize = glGetTexLevelParameterfv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLint, GLenum, *mut GLfloat) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(target, level, pname, params)
}

static glGetTexLevelParameteriv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetTexLevelParameteriv(target: GLenum, level: GLint, pname: GLenum, params: *mut GLint) -> () {
  let u: usize = glGetTexLevelParameteriv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLint, GLenum, *mut GLint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(target, level, pname, params)
}

static glGetTexParameterfv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetTexParameterfv(target: GLenum, pname: GLenum, params: *mut GLfloat) -> () {
  let u: usize = glGetTexParameterfv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLenum, *mut GLfloat) -> () = unsafe { core::mem::transmute(u) };
  _func_p(target, pname, params)
}

static glGetTexParameteriv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetTexParameteriv(target: GLenum, pname: GLenum, params: *mut GLint) -> () {
  let u: usize = glGetTexParameteriv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLenum, *mut GLint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(target, pname, params)
}

static glGetTransformFeedbackVarying_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetTransformFeedbackVarying(
  program: GLuint, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, size: *mut GLsizei, type_: *mut GLenum,
  name: *mut GLchar,
) -> () {
  let u: usize = glGetTransformFeedbackVarying_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(
    GLuint,
    GLuint,
    GLsizei,
    *mut GLsizei,
    *mut GLsizei,
    *mut GLenum,
    *mut GLchar,
  ) -> () = unsafe { core::mem::transmute(u) };
  _func_p(program, index, bufSize, length, size, type_, name)
}

static glGetUniformBlockIndex_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetUniformBlockIndex(program: GLuint, uniformBlockName: *const GLchar) -> GLuint {
  let u: usize = glGetUniformBlockIndex_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, *const GLchar) -> GLuint = unsafe { core::mem::transmute(u) };
  _func_p(program, uniformBlockName)
}

static glGetUniformIndices_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetUniformIndices(
  program: GLuint, uniformCount: GLsizei, uniformNames: *const *const GLchar, uniformIndices: *mut GLuint,
) -> () {
  let u: usize = glGetUniformIndices_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLsizei, *const *const GLchar, *mut GLuint) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(program, uniformCount, uniformNames, uniformIndices)
}

static glGetUniformLocation_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetUniformLocation(program: GLuint, name: *const GLchar) -> GLint {
  let u: usize = glGetUniformLocation_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, *const GLchar) -> GLint = unsafe { core::mem::transmute(u) };
  _func_p(program, name)
}

static glGetUniformfv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetUniformfv(program: GLuint, location: GLint, params: *mut GLfloat) -> () {
  let u: usize = glGetUniformfv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLint, *mut GLfloat) -> () = unsafe { core::mem::transmute(u) };
  _func_p(program, location, params)
}

static glGetUniformiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetUniformiv(program: GLuint, location: GLint, params: *mut GLint) -> () {
  let u: usize = glGetUniformiv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLint, *mut GLint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(program, location, params)
}

static glGetUniformuiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetUniformuiv(program: GLuint, location: GLint, params: *mut GLuint) -> () {
  let u: usize = glGetUniformuiv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLint, *mut GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(program, location, params)
}

static glGetVertexAttribIiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetVertexAttribIiv(index: GLuint, pname: GLenum, params: *mut GLint) -> () {
  let u: usize = glGetVertexAttribIiv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLenum, *mut GLint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(index, pname, params)
}

static glGetVertexAttribIuiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetVertexAttribIuiv(index: GLuint, pname: GLenum, params: *mut GLuint) -> () {
  let u: usize = glGetVertexAttribIuiv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLenum, *mut GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(index, pname, params)
}

static glGetVertexAttribPointerv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetVertexAttribPointerv(index: GLuint, pname: GLenum, pointer: *mut *mut void) -> () {
  let u: usize = glGetVertexAttribPointerv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLenum, *mut *mut void) -> () = unsafe { core::mem::transmute(u) };
  _func_p(index, pname, pointer)
}

static glGetVertexAttribfv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetVertexAttribfv(index: GLuint, pname: GLenum, params: *mut GLfloat) -> () {
  let u: usize = glGetVertexAttribfv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLenum, *mut GLfloat) -> () = unsafe { core::mem::transmute(u) };
  _func_p(index, pname, params)
}

static glGetVertexAttribiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glGetVertexAttribiv(index: GLuint, pname: GLenum, params: *mut GLint) -> () {
  let u: usize = glGetVertexAttribiv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLenum, *mut GLint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(index, pname, params)
}

static glHint_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glHint(target: GLenum, mode: GLenum) -> () {
  let u: usize = glHint_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLenum) -> () = unsafe { core::mem::transmute(u) };
  _func_p(target, mode)
}

static glInvalidateFramebuffer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glInvalidateFramebuffer(target: GLenum, numAttachments: GLsizei, attachments: *const GLenum) -> () {
  let u: usize = glInvalidateFramebuffer_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLsizei, *const GLenum) -> () = unsafe { core::mem::transmute(u) };
  _func_p(target, numAttachments, attachments)
}

static glInvalidateSubFramebuffer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glInvalidateSubFramebuffer(
  target: GLenum, numAttachments: GLsizei, attachments: *const GLenum, x: GLint, y: GLint, width: GLsizei,
  height: GLsizei,
) -> () {
  let u: usize = glInvalidateSubFramebuffer_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLsizei, *const GLenum, GLint, GLint, GLsizei, GLsizei) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(target, numAttachments, attachments, x, y, width, height)
}

static glIsBuffer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glIsBuffer(buffer: GLuint) -> GLboolean {
  let u: usize = glIsBuffer_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint) -> GLboolean = unsafe { core::mem::transmute(u) };
  _func_p(buffer)
}

static glIsEnabled_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glIsEnabled(cap: GLenum) -> GLboolean {
  let u: usize = glIsEnabled_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum) -> GLboolean = unsafe { core::mem::transmute(u) };
  _func_p(cap)
}

static glIsFramebuffer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glIsFramebuffer(framebuffer: GLuint) -> GLboolean {
  let u: usize = glIsFramebuffer_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint) -> GLboolean = unsafe { core::mem::transmute(u) };
  _func_p(framebuffer)
}

static glIsProgram_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glIsProgram(program: GLuint) -> GLboolean {
  let u: usize = glIsProgram_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint) -> GLboolean = unsafe { core::mem::transmute(u) };
  _func_p(program)
}

static glIsProgramPipeline_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glIsProgramPipeline(pipeline: GLuint) -> GLboolean {
  let u: usize = glIsProgramPipeline_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint) -> GLboolean = unsafe { core::mem::transmute(u) };
  _func_p(pipeline)
}

static glIsQuery_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glIsQuery(id: GLuint) -> GLboolean {
  let u: usize = glIsQuery_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint) -> GLboolean = unsafe { core::mem::transmute(u) };
  _func_p(id)
}

static glIsRenderbuffer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glIsRenderbuffer(renderbuffer: GLuint) -> GLboolean {
  let u: usize = glIsRenderbuffer_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint) -> GLboolean = unsafe { core::mem::transmute(u) };
  _func_p(renderbuffer)
}

static glIsSampler_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glIsSampler(sampler: GLuint) -> GLboolean {
  let u: usize = glIsSampler_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint) -> GLboolean = unsafe { core::mem::transmute(u) };
  _func_p(sampler)
}

static glIsShader_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glIsShader(shader: GLuint) -> GLboolean {
  let u: usize = glIsShader_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint) -> GLboolean = unsafe { core::mem::transmute(u) };
  _func_p(shader)
}

static glIsSync_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glIsSync(sync: GLsync) -> GLboolean {
  let u: usize = glIsSync_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLsync) -> GLboolean = unsafe { core::mem::transmute(u) };
  _func_p(sync)
}

static glIsTexture_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glIsTexture(texture: GLuint) -> GLboolean {
  let u: usize = glIsTexture_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint) -> GLboolean = unsafe { core::mem::transmute(u) };
  _func_p(texture)
}

static glIsTransformFeedback_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glIsTransformFeedback(id: GLuint) -> GLboolean {
  let u: usize = glIsTransformFeedback_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint) -> GLboolean = unsafe { core::mem::transmute(u) };
  _func_p(id)
}

static glIsVertexArray_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glIsVertexArray(array: GLuint) -> GLboolean {
  let u: usize = glIsVertexArray_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint) -> GLboolean = unsafe { core::mem::transmute(u) };
  _func_p(array)
}

static glLineWidth_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glLineWidth(width: GLfloat) -> () {
  let u: usize = glLineWidth_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLfloat) -> () = unsafe { core::mem::transmute(u) };
  _func_p(width)
}

static glLinkProgram_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glLinkProgram(program: GLuint) -> () {
  let u: usize = glLinkProgram_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(program)
}

static glMapBufferRange_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glMapBufferRange(target: GLenum, offset: GLintptr, length: GLsizeiptr, access: GLbitfield) -> *mut void {
  let u: usize = glMapBufferRange_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLintptr, GLsizeiptr, GLbitfield) -> *mut void =
    unsafe { core::mem::transmute(u) };
  _func_p(target, offset, length, access)
}

static glMemoryBarrier_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glMemoryBarrier(barriers: GLbitfield) -> () {
  let u: usize = glMemoryBarrier_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLbitfield) -> () = unsafe { core::mem::transmute(u) };
  _func_p(barriers)
}

static glMemoryBarrierByRegion_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glMemoryBarrierByRegion(barriers: GLbitfield) -> () {
  let u: usize = glMemoryBarrierByRegion_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLbitfield) -> () = unsafe { core::mem::transmute(u) };
  _func_p(barriers)
}

static glObjectLabelKHR_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glObjectLabelKHR(identifier: GLenum, name: GLuint, length: GLsizei, label: *const GLchar) -> () {
  let u: usize = glObjectLabelKHR_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLuint, GLsizei, *const GLchar) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(identifier, name, length, label)
}

static glObjectPtrLabelKHR_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glObjectPtrLabelKHR(ptr: *const void, length: GLsizei, label: *const GLchar) -> () {
  let u: usize = glObjectPtrLabelKHR_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(*const void, GLsizei, *const GLchar) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(ptr, length, label)
}

static glPauseTransformFeedback_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glPauseTransformFeedback() -> () {
  let u: usize = glPauseTransformFeedback_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn() -> () = unsafe { core::mem::transmute(u) };
  _func_p()
}

static glPixelStorei_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glPixelStorei(pname: GLenum, param: GLint) -> () {
  let u: usize = glPixelStorei_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(pname, param)
}

static glPolygonOffset_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glPolygonOffset(factor: GLfloat, units: GLfloat) -> () {
  let u: usize = glPolygonOffset_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLfloat, GLfloat) -> () = unsafe { core::mem::transmute(u) };
  _func_p(factor, units)
}

static glPopDebugGroupKHR_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glPopDebugGroupKHR() -> () {
  let u: usize = glPopDebugGroupKHR_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn() -> () = unsafe { core::mem::transmute(u) };
  _func_p()
}

static glProgramBinary_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glProgramBinary(program: GLuint, binaryFormat: GLenum, binary: *const void, length: GLsizei) -> () {
  let u: usize = glProgramBinary_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLenum, *const void, GLsizei) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(program, binaryFormat, binary, length)
}

static glProgramParameteri_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glProgramParameteri(program: GLuint, pname: GLenum, value: GLint) -> () {
  let u: usize = glProgramParameteri_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLenum, GLint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(program, pname, value)
}

static glProgramUniform1f_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glProgramUniform1f(program: GLuint, location: GLint, v0: GLfloat) -> () {
  let u: usize = glProgramUniform1f_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLint, GLfloat) -> () = unsafe { core::mem::transmute(u) };
  _func_p(program, location, v0)
}

static glProgramUniform1fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glProgramUniform1fv(program: GLuint, location: GLint, count: GLsizei, value: *const GLfloat) -> () {
  let u: usize = glProgramUniform1fv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLint, GLsizei, *const GLfloat) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(program, location, count, value)
}

static glProgramUniform1i_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glProgramUniform1i(program: GLuint, location: GLint, v0: GLint) -> () {
  let u: usize = glProgramUniform1i_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLint, GLint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(program, location, v0)
}

static glProgramUniform1iv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glProgramUniform1iv(program: GLuint, location: GLint, count: GLsizei, value: *const GLint) -> () {
  let u: usize = glProgramUniform1iv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLint, GLsizei, *const GLint) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(program, location, count, value)
}

static glProgramUniform1ui_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glProgramUniform1ui(program: GLuint, location: GLint, v0: GLuint) -> () {
  let u: usize = glProgramUniform1ui_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLint, GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(program, location, v0)
}

static glProgramUniform1uiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glProgramUniform1uiv(program: GLuint, location: GLint, count: GLsizei, value: *const GLuint) -> () {
  let u: usize = glProgramUniform1uiv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLint, GLsizei, *const GLuint) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(program, location, count, value)
}

static glProgramUniform2f_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glProgramUniform2f(program: GLuint, location: GLint, v0: GLfloat, v1: GLfloat) -> () {
  let u: usize = glProgramUniform2f_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLint, GLfloat, GLfloat) -> () = unsafe { core::mem::transmute(u) };
  _func_p(program, location, v0, v1)
}

static glProgramUniform2fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glProgramUniform2fv(program: GLuint, location: GLint, count: GLsizei, value: *const GLfloat) -> () {
  let u: usize = glProgramUniform2fv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLint, GLsizei, *const GLfloat) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(program, location, count, value)
}

static glProgramUniform2i_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glProgramUniform2i(program: GLuint, location: GLint, v0: GLint, v1: GLint) -> () {
  let u: usize = glProgramUniform2i_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLint, GLint, GLint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(program, location, v0, v1)
}

static glProgramUniform2iv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glProgramUniform2iv(program: GLuint, location: GLint, count: GLsizei, value: *const GLint) -> () {
  let u: usize = glProgramUniform2iv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLint, GLsizei, *const GLint) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(program, location, count, value)
}

static glProgramUniform2ui_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glProgramUniform2ui(program: GLuint, location: GLint, v0: GLuint, v1: GLuint) -> () {
  let u: usize = glProgramUniform2ui_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLint, GLuint, GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(program, location, v0, v1)
}

static glProgramUniform2uiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glProgramUniform2uiv(program: GLuint, location: GLint, count: GLsizei, value: *const GLuint) -> () {
  let u: usize = glProgramUniform2uiv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLint, GLsizei, *const GLuint) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(program, location, count, value)
}

static glProgramUniform3f_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glProgramUniform3f(program: GLuint, location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat) -> () {
  let u: usize = glProgramUniform3f_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLint, GLfloat, GLfloat, GLfloat) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(program, location, v0, v1, v2)
}

static glProgramUniform3fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glProgramUniform3fv(program: GLuint, location: GLint, count: GLsizei, value: *const GLfloat) -> () {
  let u: usize = glProgramUniform3fv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLint, GLsizei, *const GLfloat) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(program, location, count, value)
}

static glProgramUniform3i_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glProgramUniform3i(program: GLuint, location: GLint, v0: GLint, v1: GLint, v2: GLint) -> () {
  let u: usize = glProgramUniform3i_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLint, GLint, GLint, GLint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(program, location, v0, v1, v2)
}

static glProgramUniform3iv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glProgramUniform3iv(program: GLuint, location: GLint, count: GLsizei, value: *const GLint) -> () {
  let u: usize = glProgramUniform3iv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLint, GLsizei, *const GLint) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(program, location, count, value)
}

static glProgramUniform3ui_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glProgramUniform3ui(program: GLuint, location: GLint, v0: GLuint, v1: GLuint, v2: GLuint) -> () {
  let u: usize = glProgramUniform3ui_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLint, GLuint, GLuint, GLuint) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(program, location, v0, v1, v2)
}

static glProgramUniform3uiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glProgramUniform3uiv(program: GLuint, location: GLint, count: GLsizei, value: *const GLuint) -> () {
  let u: usize = glProgramUniform3uiv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLint, GLsizei, *const GLuint) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(program, location, count, value)
}

static glProgramUniform4f_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glProgramUniform4f(
  program: GLuint, location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat, v3: GLfloat,
) -> () {
  let u: usize = glProgramUniform4f_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLint, GLfloat, GLfloat, GLfloat, GLfloat) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(program, location, v0, v1, v2, v3)
}

static glProgramUniform4fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glProgramUniform4fv(program: GLuint, location: GLint, count: GLsizei, value: *const GLfloat) -> () {
  let u: usize = glProgramUniform4fv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLint, GLsizei, *const GLfloat) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(program, location, count, value)
}

static glProgramUniform4i_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glProgramUniform4i(program: GLuint, location: GLint, v0: GLint, v1: GLint, v2: GLint, v3: GLint) -> () {
  let u: usize = glProgramUniform4i_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLint, GLint, GLint, GLint, GLint) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(program, location, v0, v1, v2, v3)
}

static glProgramUniform4iv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glProgramUniform4iv(program: GLuint, location: GLint, count: GLsizei, value: *const GLint) -> () {
  let u: usize = glProgramUniform4iv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLint, GLsizei, *const GLint) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(program, location, count, value)
}

static glProgramUniform4ui_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glProgramUniform4ui(
  program: GLuint, location: GLint, v0: GLuint, v1: GLuint, v2: GLuint, v3: GLuint,
) -> () {
  let u: usize = glProgramUniform4ui_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLint, GLuint, GLuint, GLuint, GLuint) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(program, location, v0, v1, v2, v3)
}

static glProgramUniform4uiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glProgramUniform4uiv(program: GLuint, location: GLint, count: GLsizei, value: *const GLuint) -> () {
  let u: usize = glProgramUniform4uiv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLint, GLsizei, *const GLuint) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(program, location, count, value)
}

static glProgramUniformMatrix2fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glProgramUniformMatrix2fv(
  program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat,
) -> () {
  let u: usize = glProgramUniformMatrix2fv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(program, location, count, transpose, value)
}

static glProgramUniformMatrix2x3fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glProgramUniformMatrix2x3fv(
  program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat,
) -> () {
  let u: usize = glProgramUniformMatrix2x3fv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(program, location, count, transpose, value)
}

static glProgramUniformMatrix2x4fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glProgramUniformMatrix2x4fv(
  program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat,
) -> () {
  let u: usize = glProgramUniformMatrix2x4fv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(program, location, count, transpose, value)
}

static glProgramUniformMatrix3fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glProgramUniformMatrix3fv(
  program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat,
) -> () {
  let u: usize = glProgramUniformMatrix3fv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(program, location, count, transpose, value)
}

static glProgramUniformMatrix3x2fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glProgramUniformMatrix3x2fv(
  program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat,
) -> () {
  let u: usize = glProgramUniformMatrix3x2fv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(program, location, count, transpose, value)
}

static glProgramUniformMatrix3x4fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glProgramUniformMatrix3x4fv(
  program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat,
) -> () {
  let u: usize = glProgramUniformMatrix3x4fv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(program, location, count, transpose, value)
}

static glProgramUniformMatrix4fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glProgramUniformMatrix4fv(
  program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat,
) -> () {
  let u: usize = glProgramUniformMatrix4fv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(program, location, count, transpose, value)
}

static glProgramUniformMatrix4x2fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glProgramUniformMatrix4x2fv(
  program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat,
) -> () {
  let u: usize = glProgramUniformMatrix4x2fv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(program, location, count, transpose, value)
}

static glProgramUniformMatrix4x3fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glProgramUniformMatrix4x3fv(
  program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat,
) -> () {
  let u: usize = glProgramUniformMatrix4x3fv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(program, location, count, transpose, value)
}

static glPushDebugGroupKHR_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glPushDebugGroupKHR(source: GLenum, id: GLuint, length: GLsizei, message: *const GLchar) -> () {
  let u: usize = glPushDebugGroupKHR_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLuint, GLsizei, *const GLchar) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(source, id, length, message)
}

static glReadBuffer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glReadBuffer(src: GLenum) -> () {
  let u: usize = glReadBuffer_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum) -> () = unsafe { core::mem::transmute(u) };
  _func_p(src)
}

static glReadPixels_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glReadPixels(
  x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, type_: GLenum, pixels: *mut void,
) -> () {
  let u: usize = glReadPixels_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, *mut void) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(x, y, width, height, format, type_, pixels)
}

static glReleaseShaderCompiler_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glReleaseShaderCompiler() -> () {
  let u: usize = glReleaseShaderCompiler_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn() -> () = unsafe { core::mem::transmute(u) };
  _func_p()
}

static glRenderbufferStorage_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glRenderbufferStorage(target: GLenum, internalformat: GLenum, width: GLsizei, height: GLsizei) -> () {
  let u: usize = glRenderbufferStorage_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLenum, GLsizei, GLsizei) -> () = unsafe { core::mem::transmute(u) };
  _func_p(target, internalformat, width, height)
}

static glRenderbufferStorageMultisample_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glRenderbufferStorageMultisample(
  target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei,
) -> () {
  let u: usize = glRenderbufferStorageMultisample_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLsizei, GLenum, GLsizei, GLsizei) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(target, samples, internalformat, width, height)
}

static glResumeTransformFeedback_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glResumeTransformFeedback() -> () {
  let u: usize = glResumeTransformFeedback_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn() -> () = unsafe { core::mem::transmute(u) };
  _func_p()
}

static glSampleCoverage_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glSampleCoverage(value: GLfloat, invert: GLboolean) -> () {
  let u: usize = glSampleCoverage_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLfloat, GLboolean) -> () = unsafe { core::mem::transmute(u) };
  _func_p(value, invert)
}

static glSampleMaski_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glSampleMaski(maskNumber: GLuint, mask: GLbitfield) -> () {
  let u: usize = glSampleMaski_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLbitfield) -> () = unsafe { core::mem::transmute(u) };
  _func_p(maskNumber, mask)
}

static glSamplerParameterf_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glSamplerParameterf(sampler: GLuint, pname: GLenum, param: GLfloat) -> () {
  let u: usize = glSamplerParameterf_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLenum, GLfloat) -> () = unsafe { core::mem::transmute(u) };
  _func_p(sampler, pname, param)
}

static glSamplerParameterfv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glSamplerParameterfv(sampler: GLuint, pname: GLenum, param: *const GLfloat) -> () {
  let u: usize = glSamplerParameterfv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLenum, *const GLfloat) -> () = unsafe { core::mem::transmute(u) };
  _func_p(sampler, pname, param)
}

static glSamplerParameteri_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glSamplerParameteri(sampler: GLuint, pname: GLenum, param: GLint) -> () {
  let u: usize = glSamplerParameteri_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLenum, GLint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(sampler, pname, param)
}

static glSamplerParameteriv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glSamplerParameteriv(sampler: GLuint, pname: GLenum, param: *const GLint) -> () {
  let u: usize = glSamplerParameteriv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLenum, *const GLint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(sampler, pname, param)
}

static glScissor_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glScissor(x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> () {
  let u: usize = glScissor_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLint, GLint, GLsizei, GLsizei) -> () = unsafe { core::mem::transmute(u) };
  _func_p(x, y, width, height)
}

static glShaderBinary_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glShaderBinary(
  count: GLsizei, shaders: *const GLuint, binaryFormat: GLenum, binary: *const void, length: GLsizei,
) -> () {
  let u: usize = glShaderBinary_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLsizei, *const GLuint, GLenum, *const void, GLsizei) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(count, shaders, binaryFormat, binary, length)
}

static glShaderSource_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glShaderSource(shader: GLuint, count: GLsizei, string: *const *const GLchar, length: *const GLint) -> () {
  let u: usize = glShaderSource_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLsizei, *const *const GLchar, *const GLint) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(shader, count, string, length)
}

static glStencilFunc_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glStencilFunc(func: GLenum, ref_: GLint, mask: GLuint) -> () {
  let u: usize = glStencilFunc_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLint, GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(func, ref_, mask)
}

static glStencilFuncSeparate_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glStencilFuncSeparate(face: GLenum, func: GLenum, ref_: GLint, mask: GLuint) -> () {
  let u: usize = glStencilFuncSeparate_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLenum, GLint, GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(face, func, ref_, mask)
}

static glStencilMask_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glStencilMask(mask: GLuint) -> () {
  let u: usize = glStencilMask_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(mask)
}

static glStencilMaskSeparate_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glStencilMaskSeparate(face: GLenum, mask: GLuint) -> () {
  let u: usize = glStencilMaskSeparate_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(face, mask)
}

static glStencilOp_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glStencilOp(fail: GLenum, zfail: GLenum, zpass: GLenum) -> () {
  let u: usize = glStencilOp_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLenum, GLenum) -> () = unsafe { core::mem::transmute(u) };
  _func_p(fail, zfail, zpass)
}

static glStencilOpSeparate_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glStencilOpSeparate(face: GLenum, sfail: GLenum, dpfail: GLenum, dppass: GLenum) -> () {
  let u: usize = glStencilOpSeparate_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLenum, GLenum, GLenum) -> () = unsafe { core::mem::transmute(u) };
  _func_p(face, sfail, dpfail, dppass)
}

static glTexImage2D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glTexImage2D(
  target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum,
  type_: GLenum, pixels: *const void,
) -> () {
  let u: usize = glTexImage2D_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(
    GLenum,
    GLint,
    GLint,
    GLsizei,
    GLsizei,
    GLint,
    GLenum,
    GLenum,
    *const void,
  ) -> () = unsafe { core::mem::transmute(u) };
  _func_p(target, level, internalformat, width, height, border, format, type_, pixels)
}

static glTexImage3D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glTexImage3D(
  target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint,
  format: GLenum, type_: GLenum, pixels: *const void,
) -> () {
  let u: usize = glTexImage3D_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(
    GLenum,
    GLint,
    GLint,
    GLsizei,
    GLsizei,
    GLsizei,
    GLint,
    GLenum,
    GLenum,
    *const void,
  ) -> () = unsafe { core::mem::transmute(u) };
  _func_p(target, level, internalformat, width, height, depth, border, format, type_, pixels)
}

static glTexParameterf_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glTexParameterf(target: GLenum, pname: GLenum, param: GLfloat) -> () {
  let u: usize = glTexParameterf_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLenum, GLfloat) -> () = unsafe { core::mem::transmute(u) };
  _func_p(target, pname, param)
}

static glTexParameterfv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glTexParameterfv(target: GLenum, pname: GLenum, params: *const GLfloat) -> () {
  let u: usize = glTexParameterfv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLenum, *const GLfloat) -> () = unsafe { core::mem::transmute(u) };
  _func_p(target, pname, params)
}

static glTexParameteri_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glTexParameteri(target: GLenum, pname: GLenum, param: GLint) -> () {
  let u: usize = glTexParameteri_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLenum, GLint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(target, pname, param)
}

static glTexParameteriv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glTexParameteriv(target: GLenum, pname: GLenum, params: *const GLint) -> () {
  let u: usize = glTexParameteriv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLenum, *const GLint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(target, pname, params)
}

static glTexStorage2D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glTexStorage2D(
  target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei,
) -> () {
  let u: usize = glTexStorage2D_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLsizei, GLenum, GLsizei, GLsizei) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(target, levels, internalformat, width, height)
}

static glTexStorage2DMultisample_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glTexStorage2DMultisample(
  target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei,
  fixedsamplelocations: GLboolean,
) -> () {
  let u: usize = glTexStorage2DMultisample_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLsizei, GLenum, GLsizei, GLsizei, GLboolean) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(target, samples, internalformat, width, height, fixedsamplelocations)
}

static glTexStorage3D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glTexStorage3D(
  target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei,
) -> () {
  let u: usize = glTexStorage3D_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum, GLsizei, GLenum, GLsizei, GLsizei, GLsizei) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(target, levels, internalformat, width, height, depth)
}

static glTexSubImage2D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glTexSubImage2D(
  target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum,
  type_: GLenum, pixels: *const void,
) -> () {
  let u: usize = glTexSubImage2D_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(
    GLenum,
    GLint,
    GLint,
    GLint,
    GLsizei,
    GLsizei,
    GLenum,
    GLenum,
    *const void,
  ) -> () = unsafe { core::mem::transmute(u) };
  _func_p(target, level, xoffset, yoffset, width, height, format, type_, pixels)
}

static glTexSubImage3D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glTexSubImage3D(
  target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei,
  depth: GLsizei, format: GLenum, type_: GLenum, pixels: *const void,
) -> () {
  let u: usize = glTexSubImage3D_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(
    GLenum,
    GLint,
    GLint,
    GLint,
    GLint,
    GLsizei,
    GLsizei,
    GLsizei,
    GLenum,
    GLenum,
    *const void,
  ) -> () = unsafe { core::mem::transmute(u) };
  _func_p(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, pixels)
}

static glTransformFeedbackVaryings_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glTransformFeedbackVaryings(
  program: GLuint, count: GLsizei, varyings: *const *const GLchar, bufferMode: GLenum,
) -> () {
  let u: usize = glTransformFeedbackVaryings_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLsizei, *const *const GLchar, GLenum) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(program, count, varyings, bufferMode)
}

static glUniform1f_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glUniform1f(location: GLint, v0: GLfloat) -> () {
  let u: usize = glUniform1f_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLint, GLfloat) -> () = unsafe { core::mem::transmute(u) };
  _func_p(location, v0)
}

static glUniform1fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glUniform1fv(location: GLint, count: GLsizei, value: *const GLfloat) -> () {
  let u: usize = glUniform1fv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLint, GLsizei, *const GLfloat) -> () = unsafe { core::mem::transmute(u) };
  _func_p(location, count, value)
}

static glUniform1i_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glUniform1i(location: GLint, v0: GLint) -> () {
  let u: usize = glUniform1i_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLint, GLint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(location, v0)
}

static glUniform1iv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glUniform1iv(location: GLint, count: GLsizei, value: *const GLint) -> () {
  let u: usize = glUniform1iv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLint, GLsizei, *const GLint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(location, count, value)
}

static glUniform1ui_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glUniform1ui(location: GLint, v0: GLuint) -> () {
  let u: usize = glUniform1ui_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLint, GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(location, v0)
}

static glUniform1uiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glUniform1uiv(location: GLint, count: GLsizei, value: *const GLuint) -> () {
  let u: usize = glUniform1uiv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLint, GLsizei, *const GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(location, count, value)
}

static glUniform2f_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glUniform2f(location: GLint, v0: GLfloat, v1: GLfloat) -> () {
  let u: usize = glUniform2f_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLint, GLfloat, GLfloat) -> () = unsafe { core::mem::transmute(u) };
  _func_p(location, v0, v1)
}

static glUniform2fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glUniform2fv(location: GLint, count: GLsizei, value: *const GLfloat) -> () {
  let u: usize = glUniform2fv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLint, GLsizei, *const GLfloat) -> () = unsafe { core::mem::transmute(u) };
  _func_p(location, count, value)
}

static glUniform2i_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glUniform2i(location: GLint, v0: GLint, v1: GLint) -> () {
  let u: usize = glUniform2i_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLint, GLint, GLint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(location, v0, v1)
}

static glUniform2iv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glUniform2iv(location: GLint, count: GLsizei, value: *const GLint) -> () {
  let u: usize = glUniform2iv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLint, GLsizei, *const GLint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(location, count, value)
}

static glUniform2ui_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glUniform2ui(location: GLint, v0: GLuint, v1: GLuint) -> () {
  let u: usize = glUniform2ui_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLint, GLuint, GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(location, v0, v1)
}

static glUniform2uiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glUniform2uiv(location: GLint, count: GLsizei, value: *const GLuint) -> () {
  let u: usize = glUniform2uiv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLint, GLsizei, *const GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(location, count, value)
}

static glUniform3f_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glUniform3f(location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat) -> () {
  let u: usize = glUniform3f_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLint, GLfloat, GLfloat, GLfloat) -> () = unsafe { core::mem::transmute(u) };
  _func_p(location, v0, v1, v2)
}

static glUniform3fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glUniform3fv(location: GLint, count: GLsizei, value: *const GLfloat) -> () {
  let u: usize = glUniform3fv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLint, GLsizei, *const GLfloat) -> () = unsafe { core::mem::transmute(u) };
  _func_p(location, count, value)
}

static glUniform3i_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glUniform3i(location: GLint, v0: GLint, v1: GLint, v2: GLint) -> () {
  let u: usize = glUniform3i_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLint, GLint, GLint, GLint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(location, v0, v1, v2)
}

static glUniform3iv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glUniform3iv(location: GLint, count: GLsizei, value: *const GLint) -> () {
  let u: usize = glUniform3iv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLint, GLsizei, *const GLint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(location, count, value)
}

static glUniform3ui_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glUniform3ui(location: GLint, v0: GLuint, v1: GLuint, v2: GLuint) -> () {
  let u: usize = glUniform3ui_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLint, GLuint, GLuint, GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(location, v0, v1, v2)
}

static glUniform3uiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glUniform3uiv(location: GLint, count: GLsizei, value: *const GLuint) -> () {
  let u: usize = glUniform3uiv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLint, GLsizei, *const GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(location, count, value)
}

static glUniform4f_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glUniform4f(location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat, v3: GLfloat) -> () {
  let u: usize = glUniform4f_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLint, GLfloat, GLfloat, GLfloat, GLfloat) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(location, v0, v1, v2, v3)
}

static glUniform4fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glUniform4fv(location: GLint, count: GLsizei, value: *const GLfloat) -> () {
  let u: usize = glUniform4fv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLint, GLsizei, *const GLfloat) -> () = unsafe { core::mem::transmute(u) };
  _func_p(location, count, value)
}

static glUniform4i_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glUniform4i(location: GLint, v0: GLint, v1: GLint, v2: GLint, v3: GLint) -> () {
  let u: usize = glUniform4i_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLint, GLint, GLint, GLint, GLint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(location, v0, v1, v2, v3)
}

static glUniform4iv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glUniform4iv(location: GLint, count: GLsizei, value: *const GLint) -> () {
  let u: usize = glUniform4iv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLint, GLsizei, *const GLint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(location, count, value)
}

static glUniform4ui_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glUniform4ui(location: GLint, v0: GLuint, v1: GLuint, v2: GLuint, v3: GLuint) -> () {
  let u: usize = glUniform4ui_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLint, GLuint, GLuint, GLuint, GLuint) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(location, v0, v1, v2, v3)
}

static glUniform4uiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glUniform4uiv(location: GLint, count: GLsizei, value: *const GLuint) -> () {
  let u: usize = glUniform4uiv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLint, GLsizei, *const GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(location, count, value)
}

static glUniformBlockBinding_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glUniformBlockBinding(program: GLuint, uniformBlockIndex: GLuint, uniformBlockBinding: GLuint) -> () {
  let u: usize = glUniformBlockBinding_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLuint, GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(program, uniformBlockIndex, uniformBlockBinding)
}

static glUniformMatrix2fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glUniformMatrix2fv(location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> () {
  let u: usize = glUniformMatrix2fv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(location, count, transpose, value)
}

static glUniformMatrix2x3fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glUniformMatrix2x3fv(location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> () {
  let u: usize = glUniformMatrix2x3fv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(location, count, transpose, value)
}

static glUniformMatrix2x4fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glUniformMatrix2x4fv(location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> () {
  let u: usize = glUniformMatrix2x4fv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(location, count, transpose, value)
}

static glUniformMatrix3fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glUniformMatrix3fv(location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> () {
  let u: usize = glUniformMatrix3fv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(location, count, transpose, value)
}

static glUniformMatrix3x2fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glUniformMatrix3x2fv(location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> () {
  let u: usize = glUniformMatrix3x2fv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(location, count, transpose, value)
}

static glUniformMatrix3x4fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glUniformMatrix3x4fv(location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> () {
  let u: usize = glUniformMatrix3x4fv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(location, count, transpose, value)
}

static glUniformMatrix4fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glUniformMatrix4fv(location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> () {
  let u: usize = glUniformMatrix4fv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(location, count, transpose, value)
}

static glUniformMatrix4x2fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glUniformMatrix4x2fv(location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> () {
  let u: usize = glUniformMatrix4x2fv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(location, count, transpose, value)
}

static glUniformMatrix4x3fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glUniformMatrix4x3fv(location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> () {
  let u: usize = glUniformMatrix4x3fv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(location, count, transpose, value)
}

static glUnmapBuffer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glUnmapBuffer(target: GLenum) -> GLboolean {
  let u: usize = glUnmapBuffer_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLenum) -> GLboolean = unsafe { core::mem::transmute(u) };
  _func_p(target)
}

static glUseProgram_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glUseProgram(program: GLuint) -> () {
  let u: usize = glUseProgram_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(program)
}

static glUseProgramStages_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glUseProgramStages(pipeline: GLuint, stages: GLbitfield, program: GLuint) -> () {
  let u: usize = glUseProgramStages_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLbitfield, GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(pipeline, stages, program)
}

static glValidateProgram_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glValidateProgram(program: GLuint) -> () {
  let u: usize = glValidateProgram_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(program)
}

static glValidateProgramPipeline_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glValidateProgramPipeline(pipeline: GLuint) -> () {
  let u: usize = glValidateProgramPipeline_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(pipeline)
}

static glVertexAttrib1f_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glVertexAttrib1f(index: GLuint, x: GLfloat) -> () {
  let u: usize = glVertexAttrib1f_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLfloat) -> () = unsafe { core::mem::transmute(u) };
  _func_p(index, x)
}

static glVertexAttrib1fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glVertexAttrib1fv(index: GLuint, v: *const GLfloat) -> () {
  let u: usize = glVertexAttrib1fv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, *const GLfloat) -> () = unsafe { core::mem::transmute(u) };
  _func_p(index, v)
}

static glVertexAttrib2f_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glVertexAttrib2f(index: GLuint, x: GLfloat, y: GLfloat) -> () {
  let u: usize = glVertexAttrib2f_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLfloat, GLfloat) -> () = unsafe { core::mem::transmute(u) };
  _func_p(index, x, y)
}

static glVertexAttrib2fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glVertexAttrib2fv(index: GLuint, v: *const GLfloat) -> () {
  let u: usize = glVertexAttrib2fv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, *const GLfloat) -> () = unsafe { core::mem::transmute(u) };
  _func_p(index, v)
}

static glVertexAttrib3f_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glVertexAttrib3f(index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat) -> () {
  let u: usize = glVertexAttrib3f_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLfloat, GLfloat, GLfloat) -> () = unsafe { core::mem::transmute(u) };
  _func_p(index, x, y, z)
}

static glVertexAttrib3fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glVertexAttrib3fv(index: GLuint, v: *const GLfloat) -> () {
  let u: usize = glVertexAttrib3fv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, *const GLfloat) -> () = unsafe { core::mem::transmute(u) };
  _func_p(index, v)
}

static glVertexAttrib4f_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glVertexAttrib4f(index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat) -> () {
  let u: usize = glVertexAttrib4f_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLfloat, GLfloat, GLfloat, GLfloat) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(index, x, y, z, w)
}

static glVertexAttrib4fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glVertexAttrib4fv(index: GLuint, v: *const GLfloat) -> () {
  let u: usize = glVertexAttrib4fv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, *const GLfloat) -> () = unsafe { core::mem::transmute(u) };
  _func_p(index, v)
}

static glVertexAttribBinding_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glVertexAttribBinding(attribindex: GLuint, bindingindex: GLuint) -> () {
  let u: usize = glVertexAttribBinding_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(attribindex, bindingindex)
}

static glVertexAttribDivisor_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glVertexAttribDivisor(index: GLuint, divisor: GLuint) -> () {
  let u: usize = glVertexAttribDivisor_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(index, divisor)
}

static glVertexAttribFormat_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glVertexAttribFormat(
  attribindex: GLuint, size: GLint, type_: GLenum, normalized: GLboolean, relativeoffset: GLuint,
) -> () {
  let u: usize = glVertexAttribFormat_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLint, GLenum, GLboolean, GLuint) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(attribindex, size, type_, normalized, relativeoffset)
}

static glVertexAttribI4i_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glVertexAttribI4i(index: GLuint, x: GLint, y: GLint, z: GLint, w: GLint) -> () {
  let u: usize = glVertexAttribI4i_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLint, GLint, GLint, GLint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(index, x, y, z, w)
}

static glVertexAttribI4iv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glVertexAttribI4iv(index: GLuint, v: *const GLint) -> () {
  let u: usize = glVertexAttribI4iv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, *const GLint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(index, v)
}

static glVertexAttribI4ui_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glVertexAttribI4ui(index: GLuint, x: GLuint, y: GLuint, z: GLuint, w: GLuint) -> () {
  let u: usize = glVertexAttribI4ui_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLuint, GLuint, GLuint, GLuint) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(index, x, y, z, w)
}

static glVertexAttribI4uiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glVertexAttribI4uiv(index: GLuint, v: *const GLuint) -> () {
  let u: usize = glVertexAttribI4uiv_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, *const GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(index, v)
}

static glVertexAttribIFormat_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glVertexAttribIFormat(attribindex: GLuint, size: GLint, type_: GLenum, relativeoffset: GLuint) -> () {
  let u: usize = glVertexAttribIFormat_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLint, GLenum, GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(attribindex, size, type_, relativeoffset)
}

static glVertexAttribIPointer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glVertexAttribIPointer(
  index: GLuint, size: GLint, type_: GLenum, stride: GLsizei, pointer: *const void,
) -> () {
  let u: usize = glVertexAttribIPointer_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLint, GLenum, GLsizei, *const void) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(index, size, type_, stride, pointer)
}

static glVertexAttribPointer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glVertexAttribPointer(
  index: GLuint, size: GLint, type_: GLenum, normalized: GLboolean, stride: GLsizei, pointer: *const void,
) -> () {
  let u: usize = glVertexAttribPointer_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLint, GLenum, GLboolean, GLsizei, *const void) -> () =
    unsafe { core::mem::transmute(u) };
  _func_p(index, size, type_, normalized, stride, pointer)
}

static glVertexBindingDivisor_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glVertexBindingDivisor(bindingindex: GLuint, divisor: GLuint) -> () {
  let u: usize = glVertexBindingDivisor_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLuint, GLuint) -> () = unsafe { core::mem::transmute(u) };
  _func_p(bindingindex, divisor)
}

static glViewport_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glViewport(x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> () {
  let u: usize = glViewport_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLint, GLint, GLsizei, GLsizei) -> () = unsafe { core::mem::transmute(u) };
  _func_p(x, y, width, height)
}

static glWaitSync_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
#[inline]
pub unsafe fn glWaitSync(sync: GLsync, flags: GLbitfield, timeout: GLuint64) -> () {
  let u: usize = glWaitSync_p.load(core::sync::atomic::Ordering::Acquire);
  assert!(u != 0);
  let _func_p: unsafe extern "system" fn(GLsync, GLbitfield, GLuint64) -> () = unsafe { core::mem::transmute(u) };
  _func_p(sync, flags, timeout)
}

/// Loads all GL function pointers.
///
/// In general, one cannot statically or dynamically link to GL functions.
/// The functions are often specific to a particular GL context, and so they
/// can only be loaded at runtime, once a GL context has been created and
/// made current.
///
/// This module stores one `static` address value per GL function. When you
/// call a GL function from this module, it loads the address out of the
/// static, and if the address is non-null it calls that address (if the
/// address is null it will panic).
///
/// Calling `load_gl_functions` allows you to initialize all of the static
/// address values. This should generally be done just once, after your GL
/// context is created and made current.
///
/// ## Safety
/// * The `load_fn` you provide is passed the start of a zero-terminated string
///   naming each GL command. It must use this pointer to load that GL command's
///   pointer using the appropriate platform function, then return that value.
/// * When the platform loader fails to load a GL function it will generally
///   return the null address, though error addresses of 1, 2, 3, and -1 have
///   also been seen on some systems. All of these addresses are treated as
///   failed loads, and will store null into the `static`.
///
/// ## Failure
/// * Returns `Ok` when all functions load successfully. Otherwise you will get
///   an `Err` with a list of all functions that failed to load.
/// * The loading process does not "early return". It will always attempt to
///   load all functions, only returning the list of errors at the end.
pub unsafe fn load_gl_functions(load_fn: &dyn Fn(*const u8) -> *const void) -> Result<(), Vec<&'static str>> {
  let command_info = &[
    ("glActiveShaderProgram\0", &glActiveShaderProgram_p),
    ("glActiveTexture\0", &glActiveTexture_p),
    ("glAttachShader\0", &glAttachShader_p),
    ("glBeginQuery\0", &glBeginQuery_p),
    ("glBeginTransformFeedback\0", &glBeginTransformFeedback_p),
    ("glBindAttribLocation\0", &glBindAttribLocation_p),
    ("glBindBuffer\0", &glBindBuffer_p),
    ("glBindBufferBase\0", &glBindBufferBase_p),
    ("glBindBufferRange\0", &glBindBufferRange_p),
    ("glBindFramebuffer\0", &glBindFramebuffer_p),
    ("glBindImageTexture\0", &glBindImageTexture_p),
    ("glBindProgramPipeline\0", &glBindProgramPipeline_p),
    ("glBindRenderbuffer\0", &glBindRenderbuffer_p),
    ("glBindSampler\0", &glBindSampler_p),
    ("glBindTexture\0", &glBindTexture_p),
    ("glBindTransformFeedback\0", &glBindTransformFeedback_p),
    ("glBindVertexArray\0", &glBindVertexArray_p),
    ("glBindVertexBuffer\0", &glBindVertexBuffer_p),
    ("glBlendColor\0", &glBlendColor_p),
    ("glBlendEquation\0", &glBlendEquation_p),
    ("glBlendEquationSeparate\0", &glBlendEquationSeparate_p),
    ("glBlendFunc\0", &glBlendFunc_p),
    ("glBlendFuncSeparate\0", &glBlendFuncSeparate_p),
    ("glBlitFramebuffer\0", &glBlitFramebuffer_p),
    ("glBufferData\0", &glBufferData_p),
    ("glBufferSubData\0", &glBufferSubData_p),
    ("glCheckFramebufferStatus\0", &glCheckFramebufferStatus_p),
    ("glClear\0", &glClear_p),
    ("glClearBufferfi\0", &glClearBufferfi_p),
    ("glClearBufferfv\0", &glClearBufferfv_p),
    ("glClearBufferiv\0", &glClearBufferiv_p),
    ("glClearBufferuiv\0", &glClearBufferuiv_p),
    ("glClearColor\0", &glClearColor_p),
    ("glClearDepthf\0", &glClearDepthf_p),
    ("glClearStencil\0", &glClearStencil_p),
    ("glClientWaitSync\0", &glClientWaitSync_p),
    ("glColorMask\0", &glColorMask_p),
    ("glCompileShader\0", &glCompileShader_p),
    ("glCompressedTexImage2D\0", &glCompressedTexImage2D_p),
    ("glCompressedTexImage3D\0", &glCompressedTexImage3D_p),
    ("glCompressedTexSubImage2D\0", &glCompressedTexSubImage2D_p),
    ("glCompressedTexSubImage3D\0", &glCompressedTexSubImage3D_p),
    ("glCopyBufferSubData\0", &glCopyBufferSubData_p),
    ("glCopyTexImage2D\0", &glCopyTexImage2D_p),
    ("glCopyTexSubImage2D\0", &glCopyTexSubImage2D_p),
    ("glCopyTexSubImage3D\0", &glCopyTexSubImage3D_p),
    ("glCreateProgram\0", &glCreateProgram_p),
    ("glCreateShader\0", &glCreateShader_p),
    ("glCreateShaderProgramv\0", &glCreateShaderProgramv_p),
    ("glCullFace\0", &glCullFace_p),
    ("glDebugMessageCallbackKHR\0", &glDebugMessageCallbackKHR_p),
    ("glDebugMessageControlKHR\0", &glDebugMessageControlKHR_p),
    ("glDebugMessageInsertKHR\0", &glDebugMessageInsertKHR_p),
    ("glDeleteBuffers\0", &glDeleteBuffers_p),
    ("glDeleteFramebuffers\0", &glDeleteFramebuffers_p),
    ("glDeleteProgram\0", &glDeleteProgram_p),
    ("glDeleteProgramPipelines\0", &glDeleteProgramPipelines_p),
    ("glDeleteQueries\0", &glDeleteQueries_p),
    ("glDeleteRenderbuffers\0", &glDeleteRenderbuffers_p),
    ("glDeleteSamplers\0", &glDeleteSamplers_p),
    ("glDeleteShader\0", &glDeleteShader_p),
    ("glDeleteSync\0", &glDeleteSync_p),
    ("glDeleteTextures\0", &glDeleteTextures_p),
    ("glDeleteTransformFeedbacks\0", &glDeleteTransformFeedbacks_p),
    ("glDeleteVertexArrays\0", &glDeleteVertexArrays_p),
    ("glDepthFunc\0", &glDepthFunc_p),
    ("glDepthMask\0", &glDepthMask_p),
    ("glDepthRangef\0", &glDepthRangef_p),
    ("glDetachShader\0", &glDetachShader_p),
    ("glDisable\0", &glDisable_p),
    ("glDisableVertexAttribArray\0", &glDisableVertexAttribArray_p),
    ("glDispatchCompute\0", &glDispatchCompute_p),
    ("glDispatchComputeIndirect\0", &glDispatchComputeIndirect_p),
    ("glDrawArrays\0", &glDrawArrays_p),
    ("glDrawArraysIndirect\0", &glDrawArraysIndirect_p),
    ("glDrawArraysInstanced\0", &glDrawArraysInstanced_p),
    ("glDrawBuffers\0", &glDrawBuffers_p),
    ("glDrawElements\0", &glDrawElements_p),
    ("glDrawElementsIndirect\0", &glDrawElementsIndirect_p),
    ("glDrawElementsInstanced\0", &glDrawElementsInstanced_p),
    ("glDrawRangeElements\0", &glDrawRangeElements_p),
    ("glEnable\0", &glEnable_p),
    ("glEnableVertexAttribArray\0", &glEnableVertexAttribArray_p),
    ("glEndQuery\0", &glEndQuery_p),
    ("glEndTransformFeedback\0", &glEndTransformFeedback_p),
    ("glFenceSync\0", &glFenceSync_p),
    ("glFinish\0", &glFinish_p),
    ("glFlush\0", &glFlush_p),
    ("glFlushMappedBufferRange\0", &glFlushMappedBufferRange_p),
    ("glFramebufferParameteri\0", &glFramebufferParameteri_p),
    ("glFramebufferRenderbuffer\0", &glFramebufferRenderbuffer_p),
    ("glFramebufferTexture2D\0", &glFramebufferTexture2D_p),
    ("glFramebufferTextureLayer\0", &glFramebufferTextureLayer_p),
    ("glFrontFace\0", &glFrontFace_p),
    ("glGenBuffers\0", &glGenBuffers_p),
    ("glGenFramebuffers\0", &glGenFramebuffers_p),
    ("glGenProgramPipelines\0", &glGenProgramPipelines_p),
    ("glGenQueries\0", &glGenQueries_p),
    ("glGenRenderbuffers\0", &glGenRenderbuffers_p),
    ("glGenSamplers\0", &glGenSamplers_p),
    ("glGenTextures\0", &glGenTextures_p),
    ("glGenTransformFeedbacks\0", &glGenTransformFeedbacks_p),
    ("glGenVertexArrays\0", &glGenVertexArrays_p),
    ("glGenerateMipmap\0", &glGenerateMipmap_p),
    ("glGetActiveAttrib\0", &glGetActiveAttrib_p),
    ("glGetActiveUniform\0", &glGetActiveUniform_p),
    ("glGetActiveUniformBlockName\0", &glGetActiveUniformBlockName_p),
    ("glGetActiveUniformBlockiv\0", &glGetActiveUniformBlockiv_p),
    ("glGetActiveUniformsiv\0", &glGetActiveUniformsiv_p),
    ("glGetAttachedShaders\0", &glGetAttachedShaders_p),
    ("glGetAttribLocation\0", &glGetAttribLocation_p),
    ("glGetBooleani_v\0", &glGetBooleani_v_p),
    ("glGetBooleanv\0", &glGetBooleanv_p),
    ("glGetBufferParameteri64v\0", &glGetBufferParameteri64v_p),
    ("glGetBufferParameteriv\0", &glGetBufferParameteriv_p),
    ("glGetBufferPointerv\0", &glGetBufferPointerv_p),
    ("glGetDebugMessageLogKHR\0", &glGetDebugMessageLogKHR_p),
    ("glGetError\0", &glGetError_p),
    ("glGetFloatv\0", &glGetFloatv_p),
    ("glGetFragDataLocation\0", &glGetFragDataLocation_p),
    ("glGetFramebufferAttachmentParameteriv\0", &glGetFramebufferAttachmentParameteriv_p),
    ("glGetFramebufferParameteriv\0", &glGetFramebufferParameteriv_p),
    ("glGetInteger64i_v\0", &glGetInteger64i_v_p),
    ("glGetInteger64v\0", &glGetInteger64v_p),
    ("glGetIntegeri_v\0", &glGetIntegeri_v_p),
    ("glGetIntegerv\0", &glGetIntegerv_p),
    ("glGetInternalformativ\0", &glGetInternalformativ_p),
    ("glGetMultisamplefv\0", &glGetMultisamplefv_p),
    ("glGetObjectLabelKHR\0", &glGetObjectLabelKHR_p),
    ("glGetObjectPtrLabelKHR\0", &glGetObjectPtrLabelKHR_p),
    ("glGetPointervKHR\0", &glGetPointervKHR_p),
    ("glGetProgramBinary\0", &glGetProgramBinary_p),
    ("glGetProgramInfoLog\0", &glGetProgramInfoLog_p),
    ("glGetProgramInterfaceiv\0", &glGetProgramInterfaceiv_p),
    ("glGetProgramPipelineInfoLog\0", &glGetProgramPipelineInfoLog_p),
    ("glGetProgramPipelineiv\0", &glGetProgramPipelineiv_p),
    ("glGetProgramResourceIndex\0", &glGetProgramResourceIndex_p),
    ("glGetProgramResourceLocation\0", &glGetProgramResourceLocation_p),
    ("glGetProgramResourceName\0", &glGetProgramResourceName_p),
    ("glGetProgramResourceiv\0", &glGetProgramResourceiv_p),
    ("glGetProgramiv\0", &glGetProgramiv_p),
    ("glGetQueryObjectuiv\0", &glGetQueryObjectuiv_p),
    ("glGetQueryiv\0", &glGetQueryiv_p),
    ("glGetRenderbufferParameteriv\0", &glGetRenderbufferParameteriv_p),
    ("glGetSamplerParameterfv\0", &glGetSamplerParameterfv_p),
    ("glGetSamplerParameteriv\0", &glGetSamplerParameteriv_p),
    ("glGetShaderInfoLog\0", &glGetShaderInfoLog_p),
    ("glGetShaderPrecisionFormat\0", &glGetShaderPrecisionFormat_p),
    ("glGetShaderSource\0", &glGetShaderSource_p),
    ("glGetShaderiv\0", &glGetShaderiv_p),
    ("glGetString\0", &glGetString_p),
    ("glGetStringi\0", &glGetStringi_p),
    ("glGetSynciv\0", &glGetSynciv_p),
    ("glGetTexLevelParameterfv\0", &glGetTexLevelParameterfv_p),
    ("glGetTexLevelParameteriv\0", &glGetTexLevelParameteriv_p),
    ("glGetTexParameterfv\0", &glGetTexParameterfv_p),
    ("glGetTexParameteriv\0", &glGetTexParameteriv_p),
    ("glGetTransformFeedbackVarying\0", &glGetTransformFeedbackVarying_p),
    ("glGetUniformBlockIndex\0", &glGetUniformBlockIndex_p),
    ("glGetUniformIndices\0", &glGetUniformIndices_p),
    ("glGetUniformLocation\0", &glGetUniformLocation_p),
    ("glGetUniformfv\0", &glGetUniformfv_p),
    ("glGetUniformiv\0", &glGetUniformiv_p),
    ("glGetUniformuiv\0", &glGetUniformuiv_p),
    ("glGetVertexAttribIiv\0", &glGetVertexAttribIiv_p),
    ("glGetVertexAttribIuiv\0", &glGetVertexAttribIuiv_p),
    ("glGetVertexAttribPointerv\0", &glGetVertexAttribPointerv_p),
    ("glGetVertexAttribfv\0", &glGetVertexAttribfv_p),
    ("glGetVertexAttribiv\0", &glGetVertexAttribiv_p),
    ("glHint\0", &glHint_p),
    ("glInvalidateFramebuffer\0", &glInvalidateFramebuffer_p),
    ("glInvalidateSubFramebuffer\0", &glInvalidateSubFramebuffer_p),
    ("glIsBuffer\0", &glIsBuffer_p),
    ("glIsEnabled\0", &glIsEnabled_p),
    ("glIsFramebuffer\0", &glIsFramebuffer_p),
    ("glIsProgram\0", &glIsProgram_p),
    ("glIsProgramPipeline\0", &glIsProgramPipeline_p),
    ("glIsQuery\0", &glIsQuery_p),
    ("glIsRenderbuffer\0", &glIsRenderbuffer_p),
    ("glIsSampler\0", &glIsSampler_p),
    ("glIsShader\0", &glIsShader_p),
    ("glIsSync\0", &glIsSync_p),
    ("glIsTexture\0", &glIsTexture_p),
    ("glIsTransformFeedback\0", &glIsTransformFeedback_p),
    ("glIsVertexArray\0", &glIsVertexArray_p),
    ("glLineWidth\0", &glLineWidth_p),
    ("glLinkProgram\0", &glLinkProgram_p),
    ("glMapBufferRange\0", &glMapBufferRange_p),
    ("glMemoryBarrier\0", &glMemoryBarrier_p),
    ("glMemoryBarrierByRegion\0", &glMemoryBarrierByRegion_p),
    ("glObjectLabelKHR\0", &glObjectLabelKHR_p),
    ("glObjectPtrLabelKHR\0", &glObjectPtrLabelKHR_p),
    ("glPauseTransformFeedback\0", &glPauseTransformFeedback_p),
    ("glPixelStorei\0", &glPixelStorei_p),
    ("glPolygonOffset\0", &glPolygonOffset_p),
    ("glPopDebugGroupKHR\0", &glPopDebugGroupKHR_p),
    ("glProgramBinary\0", &glProgramBinary_p),
    ("glProgramParameteri\0", &glProgramParameteri_p),
    ("glProgramUniform1f\0", &glProgramUniform1f_p),
    ("glProgramUniform1fv\0", &glProgramUniform1fv_p),
    ("glProgramUniform1i\0", &glProgramUniform1i_p),
    ("glProgramUniform1iv\0", &glProgramUniform1iv_p),
    ("glProgramUniform1ui\0", &glProgramUniform1ui_p),
    ("glProgramUniform1uiv\0", &glProgramUniform1uiv_p),
    ("glProgramUniform2f\0", &glProgramUniform2f_p),
    ("glProgramUniform2fv\0", &glProgramUniform2fv_p),
    ("glProgramUniform2i\0", &glProgramUniform2i_p),
    ("glProgramUniform2iv\0", &glProgramUniform2iv_p),
    ("glProgramUniform2ui\0", &glProgramUniform2ui_p),
    ("glProgramUniform2uiv\0", &glProgramUniform2uiv_p),
    ("glProgramUniform3f\0", &glProgramUniform3f_p),
    ("glProgramUniform3fv\0", &glProgramUniform3fv_p),
    ("glProgramUniform3i\0", &glProgramUniform3i_p),
    ("glProgramUniform3iv\0", &glProgramUniform3iv_p),
    ("glProgramUniform3ui\0", &glProgramUniform3ui_p),
    ("glProgramUniform3uiv\0", &glProgramUniform3uiv_p),
    ("glProgramUniform4f\0", &glProgramUniform4f_p),
    ("glProgramUniform4fv\0", &glProgramUniform4fv_p),
    ("glProgramUniform4i\0", &glProgramUniform4i_p),
    ("glProgramUniform4iv\0", &glProgramUniform4iv_p),
    ("glProgramUniform4ui\0", &glProgramUniform4ui_p),
    ("glProgramUniform4uiv\0", &glProgramUniform4uiv_p),
    ("glProgramUniformMatrix2fv\0", &glProgramUniformMatrix2fv_p),
    ("glProgramUniformMatrix2x3fv\0", &glProgramUniformMatrix2x3fv_p),
    ("glProgramUniformMatrix2x4fv\0", &glProgramUniformMatrix2x4fv_p),
    ("glProgramUniformMatrix3fv\0", &glProgramUniformMatrix3fv_p),
    ("glProgramUniformMatrix3x2fv\0", &glProgramUniformMatrix3x2fv_p),
    ("glProgramUniformMatrix3x4fv\0", &glProgramUniformMatrix3x4fv_p),
    ("glProgramUniformMatrix4fv\0", &glProgramUniformMatrix4fv_p),
    ("glProgramUniformMatrix4x2fv\0", &glProgramUniformMatrix4x2fv_p),
    ("glProgramUniformMatrix4x3fv\0", &glProgramUniformMatrix4x3fv_p),
    ("glPushDebugGroupKHR\0", &glPushDebugGroupKHR_p),
    ("glReadBuffer\0", &glReadBuffer_p),
    ("glReadPixels\0", &glReadPixels_p),
    ("glReleaseShaderCompiler\0", &glReleaseShaderCompiler_p),
    ("glRenderbufferStorage\0", &glRenderbufferStorage_p),
    ("glRenderbufferStorageMultisample\0", &glRenderbufferStorageMultisample_p),
    ("glResumeTransformFeedback\0", &glResumeTransformFeedback_p),
    ("glSampleCoverage\0", &glSampleCoverage_p),
    ("glSampleMaski\0", &glSampleMaski_p),
    ("glSamplerParameterf\0", &glSamplerParameterf_p),
    ("glSamplerParameterfv\0", &glSamplerParameterfv_p),
    ("glSamplerParameteri\0", &glSamplerParameteri_p),
    ("glSamplerParameteriv\0", &glSamplerParameteriv_p),
    ("glScissor\0", &glScissor_p),
    ("glShaderBinary\0", &glShaderBinary_p),
    ("glShaderSource\0", &glShaderSource_p),
    ("glStencilFunc\0", &glStencilFunc_p),
    ("glStencilFuncSeparate\0", &glStencilFuncSeparate_p),
    ("glStencilMask\0", &glStencilMask_p),
    ("glStencilMaskSeparate\0", &glStencilMaskSeparate_p),
    ("glStencilOp\0", &glStencilOp_p),
    ("glStencilOpSeparate\0", &glStencilOpSeparate_p),
    ("glTexImage2D\0", &glTexImage2D_p),
    ("glTexImage3D\0", &glTexImage3D_p),
    ("glTexParameterf\0", &glTexParameterf_p),
    ("glTexParameterfv\0", &glTexParameterfv_p),
    ("glTexParameteri\0", &glTexParameteri_p),
    ("glTexParameteriv\0", &glTexParameteriv_p),
    ("glTexStorage2D\0", &glTexStorage2D_p),
    ("glTexStorage2DMultisample\0", &glTexStorage2DMultisample_p),
    ("glTexStorage3D\0", &glTexStorage3D_p),
    ("glTexSubImage2D\0", &glTexSubImage2D_p),
    ("glTexSubImage3D\0", &glTexSubImage3D_p),
    ("glTransformFeedbackVaryings\0", &glTransformFeedbackVaryings_p),
    ("glUniform1f\0", &glUniform1f_p),
    ("glUniform1fv\0", &glUniform1fv_p),
    ("glUniform1i\0", &glUniform1i_p),
    ("glUniform1iv\0", &glUniform1iv_p),
    ("glUniform1ui\0", &glUniform1ui_p),
    ("glUniform1uiv\0", &glUniform1uiv_p),
    ("glUniform2f\0", &glUniform2f_p),
    ("glUniform2fv\0", &glUniform2fv_p),
    ("glUniform2i\0", &glUniform2i_p),
    ("glUniform2iv\0", &glUniform2iv_p),
    ("glUniform2ui\0", &glUniform2ui_p),
    ("glUniform2uiv\0", &glUniform2uiv_p),
    ("glUniform3f\0", &glUniform3f_p),
    ("glUniform3fv\0", &glUniform3fv_p),
    ("glUniform3i\0", &glUniform3i_p),
    ("glUniform3iv\0", &glUniform3iv_p),
    ("glUniform3ui\0", &glUniform3ui_p),
    ("glUniform3uiv\0", &glUniform3uiv_p),
    ("glUniform4f\0", &glUniform4f_p),
    ("glUniform4fv\0", &glUniform4fv_p),
    ("glUniform4i\0", &glUniform4i_p),
    ("glUniform4iv\0", &glUniform4iv_p),
    ("glUniform4ui\0", &glUniform4ui_p),
    ("glUniform4uiv\0", &glUniform4uiv_p),
    ("glUniformBlockBinding\0", &glUniformBlockBinding_p),
    ("glUniformMatrix2fv\0", &glUniformMatrix2fv_p),
    ("glUniformMatrix2x3fv\0", &glUniformMatrix2x3fv_p),
    ("glUniformMatrix2x4fv\0", &glUniformMatrix2x4fv_p),
    ("glUniformMatrix3fv\0", &glUniformMatrix3fv_p),
    ("glUniformMatrix3x2fv\0", &glUniformMatrix3x2fv_p),
    ("glUniformMatrix3x4fv\0", &glUniformMatrix3x4fv_p),
    ("glUniformMatrix4fv\0", &glUniformMatrix4fv_p),
    ("glUniformMatrix4x2fv\0", &glUniformMatrix4x2fv_p),
    ("glUniformMatrix4x3fv\0", &glUniformMatrix4x3fv_p),
    ("glUnmapBuffer\0", &glUnmapBuffer_p),
    ("glUseProgram\0", &glUseProgram_p),
    ("glUseProgramStages\0", &glUseProgramStages_p),
    ("glValidateProgram\0", &glValidateProgram_p),
    ("glValidateProgramPipeline\0", &glValidateProgramPipeline_p),
    ("glVertexAttrib1f\0", &glVertexAttrib1f_p),
    ("glVertexAttrib1fv\0", &glVertexAttrib1fv_p),
    ("glVertexAttrib2f\0", &glVertexAttrib2f_p),
    ("glVertexAttrib2fv\0", &glVertexAttrib2fv_p),
    ("glVertexAttrib3f\0", &glVertexAttrib3f_p),
    ("glVertexAttrib3fv\0", &glVertexAttrib3fv_p),
    ("glVertexAttrib4f\0", &glVertexAttrib4f_p),
    ("glVertexAttrib4fv\0", &glVertexAttrib4fv_p),
    ("glVertexAttribBinding\0", &glVertexAttribBinding_p),
    ("glVertexAttribDivisor\0", &glVertexAttribDivisor_p),
    ("glVertexAttribFormat\0", &glVertexAttribFormat_p),
    ("glVertexAttribI4i\0", &glVertexAttribI4i_p),
    ("glVertexAttribI4iv\0", &glVertexAttribI4iv_p),
    ("glVertexAttribI4ui\0", &glVertexAttribI4ui_p),
    ("glVertexAttribI4uiv\0", &glVertexAttribI4uiv_p),
    ("glVertexAttribIFormat\0", &glVertexAttribIFormat_p),
    ("glVertexAttribIPointer\0", &glVertexAttribIPointer_p),
    ("glVertexAttribPointer\0", &glVertexAttribPointer_p),
    ("glVertexBindingDivisor\0", &glVertexBindingDivisor_p),
    ("glViewport\0", &glViewport_p),
    ("glWaitSync\0", &glWaitSync_p),
  ];
  let mut load_failures = Vec::new();
  for (command_name, command_p) in command_info.iter() {
    let addr: usize = match load_fn(command_name.as_ptr()) as usize {
      0 | 1 | 2 | 3 | usize::MAX => {
        load_failures.push(&command_name[..command_name.len() - 1]);
        0
      }
      other => other,
    };
    command_p.store(addr, core::sync::atomic::Ordering::Release);
  }
  if load_failures.is_empty() {
    Ok(())
  } else {
    Err(load_failures)
  }
}
